<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github-dark.min.css">
  <link rel="stylesheet" href="style.css">
  <title>Point In Time Recoveryの実践</title>
</head>
<body class="markdown-body">

<header class="header">
  <h2 class="site-title">DB技術記事</h2>
  <button class="menu-btn" id="menuBtn">☰</button>
</header>

<h1>PostgreSQLにおけるPoint In Time Recoveryの実践</h1>

<h2>1. はじめに</h2>
<p>
この講義では<span class="highlight">SQL実行</span>、<span class="highlight">トランザクション</span>、<span class="highlight">結合</span>、<span class="highlight">バックアップ/リストア</span>の基礎を理解している前提で解説する。
</p>
<p>
学習ゴールは次の3つ：①<span class="highlight-strong">PITRの構成要素</span>を説明できる、②演習環境で<span class="highlight-strong">PITRを再現</span>できる、③失敗時に原因を切り分けられる。手を動かすハンズオンと、定着確認・SQLドリルで最低90分以上の学習体験になる分量で進める。
</p>

<h2>2. 演習環境の前提</h2>
<ul>
  <li>PostgreSQL 17（Docker）</li>
  <li>授業提供の演習用コンテナ環境</li>
  <li>PowerShell / bash どちらでも可</li>
</ul>
<p>
本講義資料のリンク：<a href="https://takeshiwada1980.github.io/DB-2025/">DB-2025 講義資料 Index</a>
</p>
<p>
第12回講義のバックアップ/リストアの内容を復習してから進むとスムーズ：
<a href="https://takeshiwada1980.github.io/DB-2025/lecture12.html#%E3%83%90%E3%83%83%E3%82%AF%E3%82%A2%E3%83%83%E3%83%97%E3%81%A8%E3%83%AA%E3%82%B9%E3%83%88%E3%82%A2">第12回講義（バックアップとリストア）</a>

<h3>2.2 学習タイムライン</h3>
<ul>
  <li>2. バックアップ復習：10分（論理バックアップの限界も確認）</li>
  <li>3. PITRの仕組み：15分（タイムライン分岐の理解を追加）</li>
  <li>4. ハンズオン準備：15分（アーカイブ設定と再起動確認）</li>
  <li>4.5〜4.6 リカバリ演習：25分（ログの読み方を含む）</li>
  <li>5. トラブルシューティング：10分（失敗体験を組み込む）</li>
  <li>6-7. 定着確認・ドリル：15分</li>
</ul>
</p>

<h3>2.1 バックアップ/リストアの復習</h3>
<p>
PITRの前に、基本のバックアップ/リストアを整理しておく。ここでは<strong>論理バックアップ</strong>（SQLとして取り出す方式）を中心に復習する。
</p>
<ul>
  <li><span class="highlight">目的</span>：壊したときに「安全に戻せる」状態を作る</li>
  <li><span class="highlight">粒度</span>：DB全体 / スキーマ / テーブル単位で取得できる</li>
  <li><span class="highlight">基本思想</span>：バックアップは「取りっぱなし」ではなく、リストアできることが重要</li>
</ul>

<h4>用語の意味</h4>
<p>
<span class="highlight">バックアップ</span>は「今のデータを安全な場所に複製して保存すること」。
<span class="highlight">リストア</span>は「バックアップからデータを戻し、元の状態に復元すること」。
言い換えると、バックアップは“保険を作る”、リストアは“保険を使って元に戻す”。
</p>

<h4>バックアップの種類</h4>
<p>
バックアップには大きく<strong>論理バックアップ</strong>と<strong>物理バックアップ</strong>がある。
PITRは物理バックアップ（ベースバックアップ）とWALの組み合わせが前提になるため、
論理だけでなく物理の特徴も理解しておく必要がある。
</p>
<ul>
  <li><span class="highlight">論理バックアップ</span>：SQLとして取り出す（pg_dump）。<strong>可搬性が高い</strong>が、復元に時間がかかる。</li>
  <li><span class="highlight">物理バックアップ</span>：DBファイルを丸ごと複製（pg_basebackup）。<strong>復旧が速い</strong>が、同一バージョン前提。</li>
</ul>

<h4>論理バックアップの形式と使い分け</h4>
<p>
pg_dump の出力形式は用途で選ぶ。SQL形式は人が読めるがサイズが大きくなりやすい。
カスタム形式は圧縮・並列復元に向いている。
</p>
<pre><code class="language-bash">
# 例: SQL形式（人が読める／差分比較しやすい）
pg_dump -d mydb -f backup.sql

# 例: カスタム形式（圧縮され、pg_restore で柔軟に復元）
pg_dump -d mydb -F c -f backup.dump
</code></pre>
<ul>
  <li>SQL形式：小規模DBや学習用途に向く</li>
  <li>カスタム形式：本番運用での標準的な選択肢</li>
</ul>

<h4>論理バックアップの細かい粒度</h4>
<p>
pg_dumpはDB全体だけでなく、スキーマやテーブル単位で切り出せる。
障害対応で「一部だけ戻したい」状況に強い。
</p>
<pre><code class="language-bash">
# スキーマ単位
pg_dump -d mydb -n public -f public.sql

# テーブル単位
pg_dump -d mydb -t orders -f orders.sql
</code></pre>

<h4>リストアの基本パターン</h4>
<p>
復元は「どこに戻すか（接続先）」と「どの形式か（SQL/カスタム）」が最重要。
SQLはpsqlで流し込み、カスタム形式はpg_restoreを使う。
</p>
<pre><code class="language-bash">
# SQL形式の復元
psql -d mydb -f backup.sql

# カスタム形式の復元（必要なテーブルだけ指定も可）
pg_restore -d mydb -t orders backup.dump
</code></pre>

<h4>復元前の準備チェック</h4>
<ul>
  <li><span class="highlight">接続先の明示</span>：ホスト/ポート/DB名を明確にして誤爆を防ぐ</li>
  <li><span class="highlight">権限の整備</span>：オーナー/ロールの差分で失敗しやすい</li>
  <li><span class="highlight">空のDBを用意</span>：上書き事故を避けるため新規DBへ戻す</li>
</ul>

<h4>復元後の検証</h4>
<p>
復元したら「戻ったこと」を確認する。件数・主要テーブル・インデックスの有無を確認するだけでも、
失敗の早期発見に繋がる。
</p>
<pre><code class="language-sql">
-- 件数確認（例）
SELECT COUNT(*) FROM orders;

-- 主要テーブルの存在確認
\dt
</code></pre>

<h4>バックアップの保存戦略</h4>
<p>
バックアップは1世代だけだと「壊れたバックアップ」しか残らない可能性がある。
世代管理と保管先分離でリスクを下げる。
</p>
<ul>
  <li>複数世代を保持（例：日次×7、週次×4）</li>
  <li>本番と同一ディスクには置かない</li>
  <li>バックアップの暗号化・アクセス制御を徹底</li>
</ul>

<h4>自動化の第一歩</h4>
<p>
手動運用は抜けが起きる。まずは定期実行とログ保存だけでも導入すると、
「やったか分からない」問題がなくなる。
</p>
<pre><code class="language-bash">
# 例: ダンプの実行ログを残す（概念例）
pg_dump -d mydb -F c -f /backup/dumps/mydb_20260129.dump \
  &gt; /backup/logs/backup_20260129.log 2&gt;&amp;1
</code></pre>

<h4>よくある疑問：論理バックアップだけで十分？</h4>
<p>
論理バックアップは「その時点」への復元には強いが、<span class="highlight">時点指定の復旧</span>はできない。
PITRを行うには<strong>物理バックアップ + WAL</strong>が必須である。
</p>

<h4>論理バックアップの代表例</h4>
<p>
よく使うのは <span class="highlight">pg_dump</span> と <span class="highlight">pg_restore</span>。SQLまたはカスタム形式で保存し、必要に応じて復元する。
</p>
<pre><code class="language-bash">
# 例: 単一DBをダンプ（SQL形式）
pg_dump -d mydb -f backup.sql

# 例: SQLを流し込んで復元
psql -d mydb -f backup.sql
</code></pre>

<h4>復元の時に起きやすいポイント</h4>
<ul>
  <li>接続先が間違っていないか（誤って本番へ流さない）</li>
  <li>権限やオーナーの違いで失敗することがある</li>
  <li>復元後の整合性チェック（件数、主要テーブルの確認）は必須</li>
</ul>

<div class="column">
  <div class="column-title">復習のまとめ</div>
  <p class="column-note">
  「バックアップは取得よりも<strong>復元が成功するか</strong>が重要」。
  PITRはこの“復元”をさらに細かい時点で行う技術だと捉えると理解しやすい。
  </p>
</div>

<h4>よくない例</h4>
<ul>
  <li>バックアップを取るだけで、<span class="highlight">復元テストをしていない</span></li>
  <li>取得先が同じディスクで、障害時に<span class="highlight">同時に失われる</span></li>
  <li>本番データをそのまま持ち出し、<span class="highlight">マスキングや権限分離をしない</span></li>
  <li>運用ルールが曖昧で、<span class="highlight">誰がいつ復元するか不明</span></li>
</ul>

<h4>こういうケースもある</h4>
<ul>
  <li>巨大DBでは、まず<span class="highlight">スキーマだけ復元</span>して動作確認する</li>
  <li>アプリの都合で、<span class="highlight">特定テーブルだけ先に戻す</span>必要がある</li>
  <li>監査対応で、<span class="highlight">復元ログの保存</span>が必須になる</li>
  <li>復元先は本番ではなく、<span class="highlight">検証環境で手順を固めてから</span>本番に適用</li>
</ul>

<h4>運用の現実</h4>
<ul>
  <li>復元時間が長いなら、<span class="highlight">バックアップ世代の間隔</span>を見直す</li>
  <li>失敗原因は大抵「<span class="highlight">権限・接続先・ファイルパス</span>」のどれか</li>
  <li>手順は短く書くより、<span class="highlight">やること・やらないこと</span>を明示する</li>
</ul>

<h2>3. PITRの全体像</h2>
<p>
PITRは「<span class="highlight-strong">ベースバックアップ</span> + <span class="highlight-strong">WALアーカイブ</span> + <span class="highlight-strong">復旧設定</span>」の組み合わせで成立する。ベースバックアップはある時点の完全コピー、WALはそれ以降の更新履歴。復旧時に「どこまで戻すか（時点）」を指定する。
</p>
<ul>
  <li>ベースバックアップ：DB全体のスナップショット</li>
  <li>WALアーカイブ：更新履歴（Write-Ahead Logging）</li>
  <li>復旧設定：restore_command と recovery_target_time</li>
</ul>

<h3>3.1 PITRを使う利点</h3>
<p>
PITRの最大の利点は「<span class="highlight-strong">特定時点への巻き戻し</span>」ができることだ。たとえば誤ってテーブルを削除した場合でも、削除直前の時点に復旧できる。
これは単純なダンプ復元だけでは再現できない、時点指定の復旧という強みになる。
</p>
<p>
ただし「PITRがあるから安心」と思って<span class="highlight-strong">基本のバックアップをサボるのはNG</span>。PITRはベースバックアップがなければ成立しない。
</p>
<ul>
  <li>誤操作（DROP/UPDATE/DELETE）の直前に戻せる</li>
  <li>障害発生時の復旧範囲を最小化できる</li>
  <li>「バックアップはあるが直近データが必要」の状況に強い</li>
</ul>
<div class="column">
  <div class="column-title">コラム：トランザクション処理だけじゃダメなのか？</div>
  <p class="column-note">
  トランザクションは「その処理の中で失敗した場合に元に戻す」仕組み。誤操作が<strong>コミット済み</strong>だったり、
  既にアプリが落ちてしまった後だと、トランザクションでは戻せない。PITRは「処理が終わってしまった後」にも
  時点指定で巻き戻せるのが決定的な違い。
  </p>
</div>

<h3>3.2 WALの仕組み</h3>
<p>
WALは「<span class="highlight">先にログを書いてから実データを更新する</span>」仕組み。これにより、障害発生時でもログを再生すれば同じ状態を再現できる。
PITRはこのWALを時系列で適用し、指定時刻で止めることで「その時点のDB」を作る。
</p>
<p>
よくある誤解として「WALが全部残っていればいつでも戻れる」と思いがちだが、<span class="highlight">WALだけでは復旧できない</span>点に注意。
</p>
<ul>
  <li>WALは更新の順番を保証する</li>
  <li>アーカイブは「WALを退避して保管する」こと</li>
  <li>WALが欠落すると、その区間は復旧できない</li>
</ul>
<div class="column">
  <div class="column-title">補足：WALは「戻す」ためのログ？</div>
  <p class="column-note">
  WALは基本的に「前に進めるためのログ（REDO）」として使われる。PITRはWALを順に再生し、
  指定時刻で止めることで結果的に「戻したように見せる」仕組みだ。
  </p>
</div>
<div class="column">
  <div class="column-title">AIへのプロンプト例</div>
  <p class="column-note">
  「WAL が REDO ログである理由を、障害復旧の観点で具体例つきで説明してください。」
  </p>
</div>

<h3>3.3 ベースバックアップの役割</h3>
<p>
WALだけでは復旧できない。必ず「<span class="highlight-strong">起点となるスナップショット</span>（ベースバックアップ）」が必要になる。
たとえば、WALは「差分」なので、どこかの時点の完全コピーがないと復元先が存在しない。
</p>
<p>
現場では「ベースバックアップが古すぎて復旧が長引く」ケースもあるので、<span class="highlight">取得間隔の見直し</span>が重要。
</p>

<h3>3.4 復旧ターゲットの種類</h3>
<p>
PITRは時刻以外にも「<span class="highlight">どこで止めるか</span>」を指定できる。用途に応じて選ぶと面白い。
</p>
<ul>
  <li>recovery_target_time：時刻指定（最も直感的）</li>
  <li>recovery_target_lsn：LSN指定（より厳密）</li>
  <li>recovery_target_name：リカバリーポイント名指定</li>
</ul>
<div class="column">
  <div class="column-title">補足：LSNって何？</div>
  <p class="column-note">
  LSN（Log Sequence Number）はWALの位置を表す番号。時刻よりも厳密に位置を指定できるため、
  監査や再現性が重視されるケースで有効。
  </p>
</div>

<h3>3.4.1 タイムラインの考え方</h3>
<p>
PITRで復旧を行うと、<span class="highlight">履歴が分岐</span>して「タイムライン」が変わる。
たとえばタイムライン1から復旧すると、そこから新しいタイムライン2が始まる。
この概念を理解していないと「もう少し後の時点に戻したい」となった時に混乱しやすい。
</p>
<pre><code class="language-text">
Timeline 1: ----A----B----C----(誤操作)
                         \
Timeline 2:               ----D----E----(復旧後の新しい履歴)
</code></pre>
<p>
そのため、復旧設定に <span class="highlight">recovery_target_timeline = 'latest'</span> を明示して
最新タイムラインを追従させるのが安全。
</p>

<div class="column">
  <div class="column-title">補足：recovery_target_action の役割</div>
  <p class="column-note">
  recovery_target_action は「目標時刻に到達した後の動作」を決める。
  デフォルトは <span class="highlight">pause</span> で、読み取りはできても書き込みができない状態になる。
  書き込みを再開したい場合は <span class="highlight">promote</span> を指定するか、
  復旧後に <span class="highlight">SELECT pg_wal_replay_resume();</span> を実行して通常稼働へ移行する。
  </p>
</div>
<div class="column">
  <div class="column-title">AIへのプロンプト例</div>
  <p class="column-note">
  「PostgreSQL の LSN とは何か。PITR で使う理由を短く説明してください。」
  </p>
</div>

<h3>3.5 「ダンプ復元」との違い</h3>
<p>
pg_dump + psql の復元は「その時点の状態に戻す」だけで、時点指定ができない。
PITRは「誤操作直前」など細かい時点に戻せる点が大きな違い。
</p>

<h3>3.6 運用での考え方</h3>
<p>
PITRは運用設計とセットで考えると理解が深まる。<span class="highlight-strong">RPO</span>（失ってよい最大時間）と<span class="highlight-strong">RTO</span>（復旧に許される時間）を意識すると、
どの頻度でバックアップし、どれだけWALを保存すべきか判断できる。
</p>
<ul>
  <li>RPOが短いほどWAL欠落が許されない</li>
  <li>RTOが短いほど復旧手順の自動化が必要</li>
</ul>
<h3>3.7 ストーリーで理解するPITR</h3>
<p>
午前中の運用作業で、担当者が間違えて重要テーブルを削除してしまったとする。監視にはエラーが上がり、
ユーザから「データが消えた」と連絡が入った。ここで求められるのは、<span class="highlight">直前の時点に戻す</span>こと。
PITRはこの状況で最短復旧を実現するための選択肢になる。
</p>
<ol>
  <li>「いつ消えたか」を時刻で確定する</li>
  <li>ベースバックアップとWALアーカイブを確認</li>
  <li>復旧ターゲットを設定して再起動</li>
  <li>テーブルの整合性を検証し、業務を再開</li>
</ol>
<div class="column">
  <div class="column-title">現場メモ：時刻の確定が最重要</div>
  <p class="column-note">
  「消えた瞬間の時刻」が曖昧だと、復旧の止めどころが分からない。監査ログやアプリログと照らし合わせ、
  1分単位で時刻を確定する。
  </p>
</div>

<h3>3.8 失敗しやすいパターンと回避策</h3>
<ul>
  <li>WALアーカイブの保存先が満杯 → <span class="highlight">容量監視</span>とローテーションを設計する</li>
  <li>ベースバックアップの世代が古すぎる → <span class="highlight">定期取得</span>を必須化する</li>
  <li>復旧ターゲット時刻が未来 → <span class="highlight">ログ時刻と整合</span>をとる</li>
  <li>復旧後に書き込みできない → <span class="highlight">recovery_target_action</span> と <span class="highlight">pg_wal_replay_resume()</span> を確認する</li>
</ul>

<h3>3.9 時系列で見るPITR</h3>
<p>
「ベース → WAL適用 → ターゲット停止」という流れを頭の中で一直線に描けると理解が進む。
</p>
<ol>
  <li>ベースバックアップ取得（時刻A）</li>
  <li>WALアーカイブが蓄積（A〜B）</li>
  <li>障害発生（時刻B）</li>
  <li>復旧ターゲット（時刻B直前）で停止</li>
</ol>
<div class="column">
  <div class="column-title">AIへのプロンプト例</div>
  <p class="column-note">
  「PITRの流れを『時系列の出来事』として説明してください。1分で読める長さで。」
  </p>
</div>

<h2>4. ハンズオン学習</h2>
<h3>4.1 作業用ディレクトリの準備</h3>
<p>バックアップ先とアーカイブ先を明示的に作成する。</p>
<p>
このハンズオンは、講義資料どおりに構築済みの <span class="highlight">DB-PostgreSQL</span> フォルダを前提とする。
VSCodeでDB-PostgreSQLを開き、ターミナルはそのフォルダを作業ディレクトリにする。
</p>
<p>
まずはターミナルの作業場所とコンテナの起動状況を確認する。ここがズレると以降の作業が全部ずれるので、
最初に丁寧に確認しておく。
</p>
<pre><code class="language-bash">
# VSCodeでプロジェクトを開いた状態で実行（PowerShell想定）
pwd
</code></pre>
<p>出力が <span class="highlight">DB-PostgreSQL</span> 配下であることを確認する。</p>
<div class="column">
  <div class="column-title">補足：演習環境の起動確認</div>
  <p class="column-note">
  まだコンテナが起動していない場合は、講義資料の手順に従って起動する。
  </p>
</div>
<pre><code class="language-bash">
# Dockerコンテナ起動（講義資料の手順）
npm run db:up
</code></pre>
<pre><code class="language-bash">
# 起動確認（例）
docker ps
</code></pre>
<pre><code class="language-bash">
mkdir -p /backup/base
mkdir -p /backup/wal_archive
</code></pre>

<h3>4.2 WALアーカイブ設定の確認</h3>
<p>
まずは現在の設定を確認する。設定ファイルを直接編集する場合は、操作権限と再起動が必要になるので注意する。
</p>
<div class="column">
  <div class="column-title">Docker環境の設定ファイル編集（重要）</div>
  <p class="column-note">
  Docker環境ではコンテナ内の <span class="highlight">/var/lib/postgresql/data/postgresql.conf</span> が本体設定。
  ただし、PITRの一時的な設定は <span class="highlight">postgresql.auto.conf</span> に追記する方が安全。
  例：設定追記 → 再起動、の順に行う。
  </p>
</div>
<pre><code class="language-bash">
# 例: postgresql.auto.conf へ追記（コンテナ内）
docker exec -it db-postgres bash -c "echo \"recovery_target_time = '2026-01-27 10:30:00'\" &gt;&gt; /var/lib/postgresql/data/postgresql.auto.conf"
docker exec -it db-postgres bash -c "echo \"recovery_target_timeline = 'latest'\" &gt;&gt; /var/lib/postgresql/data/postgresql.auto.conf"
docker exec -it db-postgres bash -c "echo \"recovery_target_action = 'promote'\" &gt;&gt; /var/lib/postgresql/data/postgresql.auto.conf"
docker exec -it db-postgres bash -c "echo \"restore_command = 'cp /backup/wal_archive/%f %p'\" &gt;&gt; /var/lib/postgresql/data/postgresql.auto.conf"

# 例: 再起動で反映
docker restart db-postgres
</code></pre>
<p>
設定を変える前に、<span class="highlight">今の値を控える</span>のは必須。戻せなくなると原因調査が詰む。
</p>
<p>
SQLの実行は、講義資料どおりに <span class="highlight">VSCodeのタスク実行（Ctrl+Shift+B）</span> または
<span class="highlight">ターミナルからnpm run sql</span> を使う。以下はターミナル実行の例。
</p>
<pre><code class="language-bash">
# 例: 一時ファイルを作ってSQLを実行
code sql/tmp_pitr.sql
npm run sql sql/tmp_pitr.sql
</code></pre>
<pre><code class="language-sql">
SHOW archive_mode;
SHOW archive_command;
SHOW wal_level;
</code></pre>

<p>postgresql.conf の代表的な設定例（環境に合わせて調整）。</p>
<pre><code class="language-ini">
archive_mode = on
archive_command = 'test ! -f /backup/wal_archive/%f &amp;&amp; cp %p /backup/wal_archive/%f'
wal_level = replica
</code></pre>
<div class="column">
  <div class="column-title">補足：archive_command が失敗する代表例</div>
  <p class="column-note">
  パスの存在・権限不足・同名ファイルの衝突が多い。`test ! -f` で上書きを防ぎつつ、
  実際にアーカイブ先にファイルが作成されているか確認すること。
  </p>
</div>
<div class="column">
  <div class="column-title">AIへのプロンプト例</div>
  <p class="column-note">
  「archive_command が失敗する典型例と、確認すべきログの場所を教えてください。」
  </p>
</div>

<h3>4.3 ベースバックアップの取得</h3>
<p>ベースバックアップは復旧の起点になる。まずは取得しておく。</p>
<pre><code class="language-bash">
pg_basebackup -D /backup/base -Fp -Xs -P
</code></pre>
<p>
<strong>-D</strong> は出力先、<strong>-Fp</strong> はプレーン形式、<strong>-Xs</strong> はWALのストリーミング取得、<strong>-P</strong> は進捗表示。
</p>

<h3>4.4 WAL生成とアーカイブ確認</h3>
<h4>4.4.1 テスト用テーブル作成</h4>
<pre><code class="language-sql">
CREATE TABLE pitr_demo (
  id SERIAL PRIMARY KEY,
  message TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
</code></pre>

<h4>4.4.2 変更を発生させる</h4>
<pre><code class="language-sql">
INSERT INTO pitr_demo (message) VALUES
  ('first'),
  ('second'),
  ('third');
</code></pre>

<h4>4.4.3 WALアーカイブの生成を促す</h4>
<pre><code class="language-sql">
SELECT pg_switch_wal();
</code></pre>

<h4>4.4.4 アーカイブ確認</h4>
<pre><code class="language-bash">
ls -la /backup/wal_archive
</code></pre>

<h3>4.5 障害発生の再現</h3>
<p>削除直前の時刻を記録しておく（復旧ターゲットになる）。</p>
<pre><code class="language-sql">
SELECT now();
SELECT * FROM pitr_demo ORDER BY id;
</code></pre>

<p>誤操作（削除）を実行。</p>
<pre><code class="language-sql">
DROP TABLE pitr_demo;
</code></pre>

<h3>4.6 PITRによる復旧</h3>
<h4>4.6.1 目標時刻の設定</h4>
<p>削除直前の時刻をメモして、その時刻へ復旧する。</p>
<pre><code class="language-ini">
recovery_target_time = '2026-01-27 10:30:00'
recovery_target_timeline = 'latest'
recovery_target_action = 'promote'
</code></pre>
<p>
<span class="highlight">recovery_target_action = 'promote'</span> を指定しない場合は pause になるので、
復旧後に書き込みができない状態になる。pauseのままにする場合は、
復旧後に <span class="highlight">SELECT pg_wal_replay_resume();</span> を実行して通常稼働へ移行する。
</p>

<h4>4.6.2 リストア用の基本設定</h4>
<pre><code class="language-ini">
restore_command = 'cp /backup/wal_archive/%f %p'
</code></pre>
<p>
ここでパスを間違えると、<span class="highlight">無言で復旧が進まない</span>ことがある。ログ確認はセット。
</p>

<h4>4.6.3 復旧シグナルの用意</h4>
<pre><code class="language-bash">
touch recovery.signal
</code></pre>
<p>
Docker環境では <span class="highlight">/var/lib/postgresql/data</span> に作成する。例：
<span class="highlight">docker exec -it db-postgres bash -c "touch /var/lib/postgresql/data/recovery.signal"</span>
</p>
<div class="column">
  <div class="column-title">順序の確認（ここが最重要）</div>
  <p class="column-note">
  1) <span class="highlight">設定ファイルを反映</span>（postgresql.auto.conf へ追記） →
  2) <span class="highlight">recovery.signal を作成</span> →
  3) <span class="highlight">サーバー起動</span>（コンテナ start）。
  この順序が崩れると、設定が反映されないまま起動して復旧が進まないことがある。
  </p>
</div>

<h4>4.6.4 復旧後の確認</h4>
<pre><code class="language-sql">
SELECT * FROM pitr_demo ORDER BY id;
</code></pre>

<h4>4.6.5 復旧状況の監視コマンド</h4>
<pre><code class="language-sql">
-- 復旧中かどうか
SELECT pg_is_in_recovery();

-- 受信済み/再生済みのWAL位置
SELECT pg_last_wal_receive_lsn();
SELECT pg_last_wal_replay_lsn();

-- 最後に再生したトランザクション時刻
SELECT pg_last_xact_replay_timestamp();
</code></pre>

<h2>5. つまずきやすい点</h2>
<ul>
  <li>アーカイブ先のパスが存在しない／権限がない</li>
  <li>archive_command が失敗している（ログで確認）</li>
  <li>recovery_target_time の形式ミス</li>
  <li>ベースバックアップ取得後にWALが欠落している</li>
  <li>復旧後の起動が終了しない（ターゲット時刻未到達）</li>
  <li>復旧後にアプリが動かない（<span class="highlight">接続先が旧DBのまま</span>）</li>
</ul>

<h3>5.1 失敗体験</h3>
<p>
5〜10分だけ「わざと失敗する」時間を作ると、トラブルシューティング力が伸びる。
</p>
<ol>
  <li>restore_command のパスをわざと間違える</li>
  <li>起動後に <span class="highlight">復旧が進まない</span>ことを確認</li>
  <li><span class="highlight">docker logs db-postgres</span> でエラーを確認</li>
  <li>正しいパスに戻して復旧を再実行</li>
</ol>

<h3>5.2 WALの掃除</h3>
<p>
WALアーカイブを溜め続けるとディスクが溢れる。古いWALを削除する場合は
<span class="highlight">pg_archivecleanup</span> の利用を検討する。
</p>
<pre><code class="language-bash">
# 例: 古いWALを削除（最新のWALファイルを基準に）
pg_archivecleanup /backup/wal_archive 0000000100000000000000A3
</code></pre>

<h2>6. 定着確認</h2>
<ol>
  <li>ベースバックアップは<span class="masked">起点となる完全コピー</span>、WALアーカイブは<span class="masked">更新履歴の保管</span>を表す。</li>
  <li><span class="masked">pg_basebackup</span>はDB全体のスナップショットを取得する。</li>
  <li>archive_command が失敗した場合は<span class="masked">PostgreSQLログ</span>と<span class="masked">アーカイブ先の権限/パス</span>を確認する。</li>
  <li>recovery_target_time は<span class="masked">復旧を止める時点</span>を指定するために使う。</li>
  <li>復旧後に動作不良があれば、まず<span class="masked">WAL欠落の有無</span>を確認する。</li>
  <li>WALは基本的に<span class="masked">REDOログ</span>として機能する。</li>
  <li>PITRはWALを<span class="masked">時系列に適用</span>し、指定時刻で停止する。</li>
  <li>RPOは<span class="masked">失ってよい最大時間</span>、RTOは<span class="masked">復旧に許される時間</span>を指す。</li>
  <li>LSNは<span class="masked">WALの位置</span>を表す番号である。</li>
  <li>ベースバックアップが古すぎると<span class="masked">復旧時間が長くなる</span>。</li>
  <li>WAL保存先が満杯だと<span class="masked">アーカイブが停止</span>する。</li>
  <li>復旧ターゲット時刻は<span class="masked">ログ時刻と整合</span>を取る必要がある。</li>
  <li>復旧後に書き込みできない場合は<span class="masked">recovery.signal</span>を確認する。</li>
  <li>PITRは<span class="masked">時点指定の復旧</span>が最大の強みである。</li>
  <li>監査対応では<span class="masked">LSN指定</span>が有効な場合がある。</li>
</ol>

<h2>7. SQLドリル / 演習</h2>
<p>
ここからは <span class="highlight">x_**** テーブル群</span>を使った実務寄りのSQLドリル。必ず <span class="highlight">START TRANSACTION</span> と <span class="highlight">ROLLBACK</span> で囲んで実行すること。
</p>

<h3>7.1 PITR演習：誤操作の時刻特定と1分前復旧</h3>
<p>
PITRそのものを評価する演習を追加する。以下の流れを自分で完遂せよ。
</p>
<ol>
  <li>対象テーブルの更新前時刻を <span class="highlight">SELECT now()</span> で記録</li>
  <li>誤操作（例：DROP TABLE / DELETE）を実行</li>
  <li>ログまたはメモした時刻から <span class="highlight">1分前</span>を復旧ターゲットに設定</li>
  <li>PITRを実施して、更新前の状態に戻ることを確認</li>
</ol>
<p>
評価ポイント：<span class="highlight">時刻の特定 → 設定反映 → 復旧 → 確認</span>までの一連操作ができること。
</p>

<h3>ex-03_1：年始の一斉支給</h3>
<p><span class="highlight">難易度：★★★</span></p>
<p>
新年イベントとして、運営から全キャラへ 25,000G〜45,000G を 1,000G 刻みのランダム値で支給する送金レコードを <span class="highlight">x_gold_transfers</span> に挿入せよ。
論理削除済みキャラは除外し、<span class="highlight">transferred_at</span> は 2026-01-01 04:00:00 とする。
</p>
<p><span class="highlight">ヒント</span>：乱数生成（第09回講義）、`FLOOR(RANDOM() * n)`、`DATE/TIMESTAMP` の扱い。</p>
<pre><code class="language-sql">
-- 期待する出力イメージ（例）
--    id    | from  |   to    |  amount  |   transferred_at
-- ---------+-------+---------+----------+---------------------
--  xxxxxxxx | _SYS_ | Marvin  |   30,000 | 2026-01-01 04:00:00
--  xxxxxxxx | _SYS_ | Zach    |   38,000 | 2026-01-01 04:00:00
</code></pre>

<h3>ex-03_2：ギルド共益費の自動徴収</h3>
<p><span class="highlight">難易度：★★★★</span></p>
<p>
各ギルドで、メンバからオーナーへ「共益費」2,000Gを支払う送金レコードを作成せよ。
<span class="highlight">論理削除済みキャラは除外</span>し、オーナー本人は自分のギルドへ支払わない。
transferred_at は 2025-12-15 04:00:00 固定とする。
</p>
<p><span class="highlight">ヒント</span>：x_guilds、x_guild_characters、x_characters の結合、オーナーIDの取得。</p>
<pre><code class="language-sql">
-- 期待する出力イメージ（例）
--    id    |  from  |   to   |  amount  |   transferred_at
-- ---------+--------+--------+----------+---------------------
--  xxxxxxxx | Alice  | Marvin |    2,000 | 2025-12-15 04:00:00
--  xxxxxxxx | Oscar  | Bob    |    2,000 | 2025-12-15 04:00:00
</code></pre>

<h3>ex-03_3：新規作成キャラへの初期資金配布</h3>
<p><span class="highlight">難易度：★★★</span></p>
<p>
運営から各キャラへ 1,000G を支給する送金レコードを作成せよ。
論理削除済みのキャラも含める。<span class="highlight">transferred_at は created_at の5分後</span>にすること。
</p>
<p><span class="highlight">ヒント</span>：`INTERVAL` の加算、TIMESTAMP演算。</p>
<pre><code class="language-sql">
-- 期待する出力イメージ（例）
--    id    | from  |   to    |  amount  |   transferred_at
-- ---------+-------+---------+----------+---------------------
</code></pre>

<footer class="footer">
  <a class="footer-link" href="https://github.com/Tsubasa213" target="_blank" rel="noopener noreferrer">GitHub</a>
  <p class="footer-text">© copyright 2026 Tsubasa213/つばさ all right resolved.</p>
</footer>

</body>
<script src="main.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
</html>



<!-- https://qiita.com/yaju/items/51e7b1037a99856e547c　めも -->