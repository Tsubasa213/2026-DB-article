<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github-dark.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
  <link rel="stylesheet" href="style.css">
  <title>Point In Time Recoveryの実践</title>
</head>
<body class="markdown-body">

<header class="header">
  <h2 class="site-title">DB技術記事</h2>
  <button class="menu-btn" id="menuBtn">☰</button>
</header>

<h1>PostgreSQLにおけるPoint In Time Recovery</h1>

<h2>1. はじめに</h2>
<p>
前提知識は<span class="highlight">SQL実行</span>、<span class="highlight">トランザクション</span>、<span class="highlight">結合</span>、<span class="highlight">バックアップ/リストア</span>の基礎です。
</p>
<p>
本資料では<span class="highlight-strong">PITRの構成要素</span>、演習環境での<span class="highlight-strong">PITR再現手順</span>、失敗時の切り分けに焦点を置きます。
</p>

<h2>2. 実験環境</h2>
<ul>
  <li>PostgreSQL 17 / Docker</li>
  <li>授業提供の演習用コンテナ環境</li>
</ul>
<p>
参考リンク：<a href="https://takeshiwada1980.github.io/DB-2025/">DB-2025 講義資料 Index</a>
</p>
<p>
第12回講義のバックアップ/リストアの内容を復習してから進むとスムーズ：
<a href="https://takeshiwada1980.github.io/DB-2025/lecture12.html#%E3%83%90%E3%83%83%E3%82%A2%E3%83%83%E3%83%97%E3%81%A8%E3%83%AA%E3%82%B9%E3%83%88%E3%82%A2">第12回講義: バックアップとリストア</a>
</p>

<h2>3. 前提知識の復習</h2>
<h3>3.1 バックアップ/リストアの復習</h3>
<p>
PITRの前に、基本のバックアップ/リストアを整理します。ここでは<strong>論理バックアップ</strong>を中心に扱い、SQLとして取り出す方式を確認します。
</p>
<ul>
  <li><span class="highlight">目的</span>：障害時に安全に戻せる状態を確保します。</li>
  <li><span class="highlight">粒度</span>：DB全体 / スキーマ / テーブル単位で取得可能です。</li>
  <li><span class="highlight">基本思想</span>：取得だけで終えず、リストア成功まで確認します。</li>
</ul>

<h4>用語の意味</h4>
<p>
<span class="highlight">バックアップ</span>は、データを安全な場所に複製して保存することです。
<span class="highlight">リストア</span>は、バックアップからデータを戻し、元の状態に復元することです。
</p>

<h4>バックアップの種類</h4>
<p>
バックアップには大きく<strong>論理バックアップ</strong>と<strong>物理バックアップ</strong>があります。
PITRはベースバックアップとWAL（Write-Ahead Logging）の組み合わせが前提です。
そのため、論理だけでなく物理バックアップの特徴も把握しておく必要があります。
</p>
<ul>
  <li><span class="highlight">論理バックアップ</span>：SQLとして取り出します。<code>pg_dump</code> を使います。<strong>可搬性が高い</strong>一方で、復元に時間がかかります。</li>
  <li><span class="highlight">物理バックアップ</span>：DBファイルを丸ごと複製します。<code>pg_basebackup</code> を使います。<strong>復旧が速い</strong>ですが、同一バージョン前提です。</li>
</ul>

<h4>論理バックアップの形式と使い分け</h4>
<p>
<code>pg_dump</code> の出力形式は用途で選びます。SQL形式は人が読めますが、サイズが大きくなりやすいです。
カスタム形式は圧縮・並列復元に向いています。
</p>
<pre><code class="language-bash">
# 例: SQL形式
pg_dump -d mydb -f backup.sql

# 例: カスタム形式
pg_dump -d mydb -F c -f backup.dump
</code></pre>
<ul>
  <li>SQL形式：小規模DBや学習用途に向く</li>
  <li>カスタム形式：本番運用での標準的な選択肢</li>
</ul>

<details>
  <summary>：論理バックアップと物理バックアップをどう使い分けますか？</summary>
  <p>
    「テーブル単位で戻したいケース」と「障害直後に全体を早く戻したいケース」をそれぞれ想定し、
    どちらの方式を選ぶか理由つきで説明してみてください。
  </p>
</details>

<h4>論理バックアップの細かい粒度</h4>
<p>
<code>pg_dump</code> はDB全体だけでなく、スキーマやテーブル単位で切り出せます。
障害対応で「一部だけ戻したい」状況に強みがあります。
</p>
<pre><code class="language-bash">
# スキーマ単位
pg_dump -d mydb -n public -f public.sql

# テーブル単位
pg_dump -d mydb -t orders -f orders.sql
</code></pre>

<h4>リストアの基本パターン</h4>
<p>
復元では接続先と形式の指定が重要です。SQLは <code>psql</code> で流し込み、カスタム形式は <code>pg_restore</code> を使います。
</p>
<pre><code class="language-bash">
# SQL形式の復元
psql -d mydb -f backup.sql

# カスタム形式の復元（必要なテーブルだけ指定も可）
pg_restore -d mydb -t orders backup.dump
</code></pre>

<h4>復元前の準備チェック</h4>
<ul>
  <li><span class="highlight">接続先の明示</span>：ホスト/ポート/DB名を明確にして誤爆を防ぐ</li>
  <li><span class="highlight">権限の整備</span>：オーナー/ロールの差分で失敗しやすい</li>
  <li><span class="highlight">空のDBを用意</span>：上書き事故を避けるため新規DBへ戻す</li>
</ul>

<h4>復元後の検証</h4>
<p>
復元後は件数・主要テーブル・インデックスの有無を確認し、早期に異常を検知してください。
</p>
<pre><code class="language-sql">
-- 件数確認
SELECT COUNT(*) FROM orders;

-- 主要テーブルの存在確認
\dt
</code></pre>

<h4>バックアップの保存戦略</h4>
<p>
バックアップを1世代だけ保持すると「壊れたバックアップ」しか残らない可能性があります。
世代管理と保管先の分離でリスクを下げてください。
</p>
<ul>
  <li>複数世代を保持。日次×7、週次×4 など</li>
  <li>本番と同一ディスクには置かない</li>
  <li>バックアップの暗号化・アクセス制御を徹底</li>
</ul>

<h4>自動化の第一歩</h4>
<p>
手動運用の抜けを防ぐため、定期実行とログ保存の導入を推奨します。
</p>
<pre><code class="language-bash">
# 例: ダンプの実行ログを残す
pg_dump -d mydb -F c -f /backup/dumps/mydb_20260129.dump \
  &gt; /backup/logs/backup_20260129.log 2&gt;&amp;1
</code></pre>

<div class="column">
  <div class="column-title">よくある疑問：論理バックアップだけで十分か</div>
  <p class="column-note">
    論理バックアップだけでは時点指定の復旧に対応できません。PITRには<strong>物理バックアップ + WAL</strong>が<span class="critical-text">必須</span>です。
  </p>
</div>

<h4>論理バックアップの代表例</h4>
<p>
よく使うのは <code>pg_dump</code> と <code>pg_restore</code> です。SQLまたはカスタム形式で保存し、必要に応じて復元します。
</p>
<pre><code class="language-bash">
# 例: 単一DBをダンプ
pg_dump -d mydb -f backup.sql

# 例: SQLを流し込んで復元
psql -d mydb -f backup.sql
</code></pre>

<h4>復元の時に起きやすいポイント</h4>
<ul>
  <li>接続先を取り違えやすい。実行前にホスト/ポート/DB名を再確認し、誤って本番へ流し込まない</li>
  <li>権限やオーナーの差分で復元が失敗しやすい。事前にロールと所有者の整合を確認する</li>
  <li>復元後の確認を省略しやすい。<span class="critical-text">件数</span>と<span class="critical-text">主要テーブルの存在</span>を必ず確認する</li>
</ul>

<p>
ここまででバックアップ/リストアの基礎が揃いました。次の「復習の要点」で、PITR理解に必要な観点を短く確認します。
</p>

<div class="column">
  <div class="column-title">復習の要点</div>
  <p class="column-note">
  バックアップは取得よりも<strong>復元が成功するか</strong>が重要です。
  PITRは、復元を時点指定で行う技術として位置付けます。
  </p>
</div>

<h4>よくない例</h4>
<ul>
  <li>バックアップを取るだけで、<span class="highlight">復元テストをしていない</span></li>
  <li>取得先が同じディスクで、障害時に<span class="highlight">同時に失われる</span></li>
  <li>本番データをそのまま持ち出し、<span class="highlight">マスキングや権限分離をしない</span></li>
  <li>運用ルールが曖昧で、<span class="highlight">誰がいつ復元するか不明</span></li>
</ul>

<h4>こういうケースもある</h4>
<ul>
  <li>巨大DBでは、まず<span class="highlight">スキーマだけ復元</span>して動作確認する</li>
  <li>アプリの都合で、<span class="highlight">特定テーブルだけ先に戻す</span>必要がある</li>
  <li>監査対応で、<span class="highlight">復元ログの保存</span>が必須になる</li>
  <li>復元先は本番ではなく、<span class="highlight">検証環境で手順を固めてから</span>本番に適用</li>
</ul>

<h4>運用の現実</h4>
<ul>
  <li>復元時間が長いなら、<span class="highlight">バックアップ世代の間隔</span>を見直す</li>
  <li>失敗原因は大抵「<span class="highlight">権限・接続先・ファイルパス</span>」のどれか</li>
  <li>手順は短く書くより、<span class="highlight">やること・やらないこと</span>を明示する</li>
</ul>

<h3>定着確認（第3章）</h3>
<ul>
  <li>論理バックアップだけで時点指定復旧は<span class="masked">できない</span>。</li>
  <li>PITRには<span class="masked">物理バックアップ + WAL</span>の組み合わせが必要です。</li>
  <li>復元後は件数確認などの<span class="masked">整合性チェック</span>を必ず行う。</li>
</ul>

<h2>4. PITRの全体像</h2>
<p>
PITRは「<span class="highlight-strong">ベースバックアップ</span> + <span class="highlight-strong">WALアーカイブ</span> + <span class="highlight-strong">復旧設定</span>」の組み合わせで成立します。ベースバックアップはある時点の完全コピー、WALはそれ以降の更新履歴です。復旧時には戻す時点を指定します。
</p>
<ul>
  <li>ベースバックアップ：DB全体のスナップショット</li>
  <li>WALアーカイブ：更新履歴を保管する</li>
  <li>復旧設定：<code>restore_command</code> と <code>recovery_target_time</code></li>
</ul>

<h3>4.1 PITRを使う利点</h3>
<p>
PITRの利点は<span class="highlight-strong">特定時点への復旧</span>ができることです。誤ってテーブルを削除した場合でも、削除直前の時点に復旧できます。
</p>
<p>
PITRはベースバックアップがなければ成立しません。基本のバックアップは必須です。
</p>
<ul>
  <li>誤操作の直前に戻せる。<code>DROP</code>/<code>UPDATE</code>/<code>DELETE</code> など</li>
  <li>障害発生時の復旧範囲を最小化できる</li>
  <li>「バックアップはあるが直近データが必要」の状況に強い</li>
</ul>
<div class="column">
  <div class="column-title">コラム：トランザクション処理だけでは不十分か</div>
  <p class="column-note">
  トランザクションは「その処理の中で失敗した場合に元に戻す」仕組み。誤操作が<strong>コミット済み</strong>だったり、
  既にアプリが落ちてしまった後だと、トランザクションでは戻せない。PITRは「処理が終わってしまった後」にも
  時点指定で巻き戻せるのが決定的な違い。
  </p>
</div>

<h3>4.2 WALの仕組み</h3>
<p>
WALは<span class="highlight">先にログを書いてから実データを更新する</span>仕組みです。障害発生時でもログを再生すれば同じ状態を再現できます。PITRはこのWALを時系列で適用し、指定時刻で停止します。
</p>
<p>
WALが残っていても<span class="highlight">WALだけでは復旧できない</span>点に注意してください。
</p>
<ul>
  <li>WALは更新の順番を保証する</li>
  <li>アーカイブは「WALを退避して保管する」こと</li>
  <li>WALが欠落すると、その区間は復旧できない</li>
</ul>
<div class="column">
  <div class="column-title">補足：WALは「戻す」ためのログか</div>
  <p class="column-note">
  WALは基本的に「前に進めるためのログ、REDO」として使われます。PITRはWALを順に再生し、
  指定時刻で止めることで結果的に「戻したように見せる」仕組みです。
  </p>
</div>
<div class="column">
  <div class="column-title">参考質問例</div>
  <p class="column-note">
  「WALがREDOログとして機能する理由を、障害発生時の復旧手順（ログ再生の流れ）に沿って説明してください。あわせて、UNDOと誤解されやすい点も補足してください。」
  </p>
</div>

<div class="column">
  <div class="column-title">演習：WALだけで復旧できない理由を説明してください</div>
  <p class="column-note">
    「完全コピーがない状態」と「完全コピーがある状態」で、復旧できる範囲がどう違うかを比較して説明してください。
  </p>
</div>

<h3>4.3 ベースバックアップの役割</h3>
<p>
WALだけでは復旧できません。<span class="highlight-strong">起点となるスナップショット</span>が必要です。
WALは差分情報のため、完全コピーがなければ復元できません。
</p>
<p>
ベースバックアップが古いと復旧が長引くため、<span class="highlight">取得間隔の見直し</span>が重要です。
</p>

<h3>4.4 復旧ターゲットの種類</h3>
<p>
PITRは時刻以外にも停止位置を指定できます。
</p>
<ul>
  <li><code>recovery_target_time</code>：時刻指定。直感的</li>
  <li><code>recovery_target_lsn</code>：LSN指定。より厳密</li>
  <li><code>recovery_target_name</code>：リカバリーポイント名指定</li>
</ul>
<div class="column">
  <div class="column-title">補足：LSNの定義</div>
  <p class="column-note">
  LSNはLog Sequence Numberの略で、WALの位置を表す番号。時刻よりも厳密に位置を指定できるため、
  監査や再現性が重視されるケースで有効。
  </p>
</div>

<h3>4.4.1 タイムラインの考え方</h3>
<p>
PostgreSQLにおけるタイムラインは、<span class="highlight">WAL再生の履歴系統</span>を識別・管理するための概念です。
通常運用時は1本の履歴を進みますが、PITRで過去時点に復旧して再開すると、新しい履歴系統が作られます。
その結果、元の履歴から<span class="highlight">分岐した新しいタイムライン</span>が始まります。
</p>
<pre><code class="language-text">
Timeline 1: ----A----B----C----(誤操作)
                         \
Timeline 2:               ----D----E----(復旧後の新しい履歴)
</code></pre>
<p>
復旧設定に <span class="highlight"><code>recovery_target_timeline = 'latest'</code></span> を明示すると、最新タイムラインを追従できます。
</p>

<div class="column">
  <div class="column-title">補足：<code>recovery_target_action</code> の役割</div>
  <p class="column-note">
  <code>recovery_target_action</code> は「目標時刻に到達した後の動作」を決める。
  デフォルトは <span class="highlight">pause</span> で、読み取りはできても書き込みができない状態になります。
  書き込みを再開したい場合は <span class="highlight">promote</span> を指定するか、
  復旧後に <span class="highlight">SELECT pg_wal_replay_resume();</span> を実行して通常稼働へ移行します。
  </p>
</div>
<div class="column">
  <div class="column-title">参考質問例</div>
  <p class="column-note">
  「PostgreSQLのLSNとは何を表す値かを説明し、<code>recovery_target_time</code> と比べたときにLSN指定が有利になる場面を1つ挙げてください。」
  </p>
</div>

<h3>4.5 「ダンプ復元」との違い</h3>
<p>
<code>pg_dump</code> + <code>psql</code> の復元は「ダンプ取得時点へ戻す」方式であり、時点指定には対応できません。
一方、PITRはベースバックアップとWALを組み合わせることで、「誤操作直前」など細かい時点へ戻せます。
</p>
<ul>
  <li><span class="highlight">復旧粒度</span>：<code>pg_dump</code> + <code>psql</code> は取得時点単位、PITRは秒単位の時点指定に対応します。</li>
  <li><span class="highlight">主な用途</span>：論理バックアップは移行・部分復元、PITRは障害直前への巻き戻しに向きます。</li>
  <li><span class="highlight">前提条件</span>：PITRにはベースバックアップ運用とWALアーカイブ運用の両方が必要です。</li>
</ul>

<div class="column">
  <div class="column-title">実務での使い分け</div>
  <p class="column-note">
    「誤操作の数分前に戻したい」ならPITRを選択します。
    「環境移行や一部データの取り出し」が目的なら、<code>pg_dump</code>/<code>pg_restore</code> を優先します。
  </p>
</div>

<h3>4.6 運用での考え方</h3>
<p>
PITRは運用設計とセットで扱います。<span class="highlight-strong">RPO</span>は失ってよい最大時間、<span class="highlight-strong">RTO</span>は復旧に許される時間です。これらを意識すると、
どの頻度でバックアップし、どれだけWALを保存すべきかを判断できます。
</p>
<ul>
  <li>RPOが短いほどWAL欠落を許容できません。</li>
  <li>RTOが短いほど復旧手順の自動化が必要です。</li>
</ul>
<h3>4.7 事例で見るPITR</h3>
<p>
午前中の運用作業で、担当者が間違えて重要テーブルを削除してしまったとします。監視にはエラーが上がり、
ユーザから「データが消えた」と連絡が入りました。ここで求められるのは、<span class="highlight">直前の時点に戻す</span>ことです。
PITRはこの状況で最短復旧を実現するための有力な選択肢になります。
</p>
<ol>
  <li>「いつ消えたか」を時刻で確定する</li>
  <li>ベースバックアップとWALアーカイブを確認</li>
  <li>復旧ターゲットを設定して再起動</li>
  <li>テーブルの整合性を検証し、業務を再開</li>
</ol>
<div class="column">
  <div class="column-title">現場メモ：時刻の確定が最重要</div>
  <p class="column-note">
  「消えた瞬間の時刻」が曖昧だと、復旧の止めどころが分からない。監査ログやアプリログと照らし合わせ、
  1分単位で時刻を確定します。
  </p>
</div>

<h3>4.8 失敗しやすいパターンと回避策</h3>
<ul>
  <li>WALアーカイブの保存先が満杯 → <span class="highlight">容量監視</span>とローテーションを設計する</li>
  <li>ベースバックアップの世代が古すぎる → <span class="highlight">定期取得</span>を必須化する</li>
  <li>復旧ターゲット時刻が未来 → <span class="highlight">ログ時刻と整合</span>をとる</li>
  <li>復旧後に書き込みできない → <span class="highlight"><code>recovery_target_action</code></span> と <span class="highlight"><code>pg_wal_replay_resume()</code></span> を確認する</li>
</ul>

<h3>4.9 時系列で見るPITR</h3>
<p>
PITRは「まず起点を用意し、次に更新履歴を順に再生し、最後に指定時点で止める」流れです。
</p>

<div class="column">
  <div class="column-title">図解：PITRの時系列フロー</div>
  <pre><code class="language-text">
<span class="time-a">時刻A</span>                    <span class="time-b">時刻B</span>(障害)
 |--------------------------|
 [ベースバックアップ]   [誤操作発生]
         WALアーカイブ（A→B）を順に再生
                          ^
                          |
                復旧ターゲット（B直前）で停止
  </code></pre>
  <p class="column-note">
    ポイントは「ベースバックアップを起点に、WALを前から適用し、目標時点で止める」ことです。
  </p>
</div>

<ol>
  <li><span class="time-a">時刻A</span>でベースバックアップを取得し、復旧の起点を作ります。</li>
  <li><span class="time-a">時刻A</span>から<span class="time-b">時刻B</span>までの更新は、WALアーカイブとして蓄積されます。</li>
  <li><span class="time-b">時刻B</span>で障害または誤操作が発生します。</li>
  <li>復旧時はWALをAから順に適用し、<span class="time-b">時刻B</span>の直前で再生を停止します。</li>
</ol>
<div class="column">
  <div class="column-title">参考質問例</div>
  <p class="column-note">
  「PITRの処理を『ベースバックアップ取得 → WAL蓄積 → 目標時点で停止』の順で説明し、各段階で確認すべきログ/設定を1つずつ挙げてください。」
  </p>
</div>

<h3>定着確認（第4章）</h3>
<ul>
  <li>WALは基本的に<span class="masked">REDOログ</span>として機能する。</li>
  <li>WALだけでは復旧できず、<span class="masked">ベースバックアップ</span>が起点として必要です。</li>
  <li>時点指定復旧で厳密な位置を指定する場合は<span class="masked">LSN</span>が有効です。</li>
</ul>

<h3>4.10 時刻特定の手法・自動ログと手動記録</h3>
<p>
PITRで最も難しいのは「何時何分何秒に戻すべきか」を特定することです。これには主に2つの自動ログが活用されます。
</p>
<div class="column">
  <div class="column-title">1. データベースによる実行ログ（postgresql.log）</div>
  <p class="column-note">
    PostgreSQLの設定で <code>log_statement = 'all'</code> が有効な場合、実行されたすべてのSQLとその時刻がログファイルに自動記録されます。実務ではこのログから「誤操作が行われた正確な時刻」を特定します。
  </p>
</div>
<div class="column">
  <div class="column-title">2. テーブル設計による自動タイムスタンプ</div>
  <p class="column-note">
    今回の演習で使用する <code>x_gold_transfers</code> には、データ挿入時に自動で時刻を記録する <code>transferred_at</code> カラムが定義されています。このように、データそのものに「いつ作られたか」が自動で刻まれる設計にしておくことも、復旧時の重要な手がかりとなります。
  </p>
</div>
<h2>5. ハンズオン学習</h2>
<p>
この章では、誤操作の直前時刻に戻せることを目標に、PITRの設定から復旧確認までを実施します。
</p>

<div class="column">
  <div class="column-title">この章の目的</div>

  <ul class="column-note">
    <li><strong>リカバリ準備</strong>：WALアーカイブ設定を有効化し、常に復旧可能な状態を構築します。</li>
    <li><strong>障害再現と復旧</strong>：誤操作（例: <code>DROP TABLE</code>）をあえて実行し、ターゲット時刻を指定して巻き戻します。</li>
    <li><strong>通常稼働への復帰</strong>：リカバリ状態を確認し、書き込み可能な通常状態へプロモートします。</li>
  </ul>
</div>


<h3>5.1 ホストとコンテナの境界を理解する</h3>
<p>
  ハンズオンを進めるにあたり、「自分のPC（ホスト環境）」と「Dockerコンテナ内部」の違いを正確に把握することが非常に重要です。
</p>
<div class="column">
  <div class="column-title">コンテナ内の操作について</div>
  <p class="column-note">
    コンテナとは、Dockerによって構築された<strong>「完全に隔離された独立したデータベースサーバー」</strong>です。
    そのため、コンテナ内部のファイル（設定ファイルなど）は、普段使っているVS Codeのエクスプローラー（ファイルツリー）からは直接見えませんし、クリックして編集することもできません。
    本演習では、ホスト側のターミナルから <code>docker exec</code> コマンドを使用して、コンテナ内部へ直接指示（コマンド）を送り込むことでファイルを操作します。
  </p>
</div>

<p>
  以下の階層図を見て、作業場所が「ホスト側」か「コンテナ内部」かを混同しないよう注意してください。
</p>

<pre><code class="language-text">
DB-PostgreSQL/ (ホスト側の作業ルート：VS Codeで直接編集可能)
└── sql/
    └── tmp_pitr.sql            # 今回のハンズオンで実行するSQLを記述するファイル（新規作成）

[Dockerコンテナ内部: /var/lib/postgresql/data/] (隔離領域：dockerコマンド経由で操作)
├── postgresql.auto.conf    # 復旧コマンドや目標時刻を動的に設定するファイル（追記編集）
└── recovery.signal         # 存在するとDBが「リカバリモード」で起動するフラグファイル（新規作成）
</code></pre>

<p>まずはホスト側で、後ほど使用するSQL実行用の空ファイルを作成しておきます。</p>
<pre><code class="language-bash">
# ホスト側のターミナル（VS Codeのターミナル等）で実行
touch sql/tmp_pitr.sql
</code></pre>
<p>
  ※ コンテナ内部のファイル（<code>postgresql.auto.conf</code> や <code>recovery.signal</code>）に対する作成・編集については、この後のリカバリ手順の中で <code>docker exec</code> コマンドを用いて実行します。
</p>

<h3>5.2 演習で使用するテーブル</h3>
<p>
  本章のハンズオンでは、PITRが正常に機能するかを確認するため、専用の練習用テーブルを使用します。
</p>
<ul>
  <li><strong>pitr_demo</strong>：導入ハンズオン用。データの挿入と削除を行い、指定した時刻へ正確に戻れるかをテストします。</li>
</ul>

<h3>5.3 実行の全体フロー</h3>
<ol>
  <li><strong>設定と再起動</strong>：コンテナ内の <code>postgresql.auto.conf</code> にリカバリ設定を書き込み、コンテナを再起動します。</li>
  <li><strong>演習実行と記録</strong>：作成した <code>sql/tmp_pitr.sql</code> を <code>npm run sql sql/tmp_pitr.sql</code> で実行し、「誤操作が起きた時刻」を正確にメモします。</li>
  <li><strong>通常稼働への復帰</strong>：データが復旧したことを確認した後、<code>SELECT pg_wal_replay_resume();</code> を実行して書き込み可能な状態へ移行します。</li>
</ol>

<h3>5.4 作業用ディレクトリの準備</h3>
<p>バックアップ先とアーカイブ先を明示的に作成します。</p>
<p>
このハンズオンは、講義資料どおりに構築済みの <span class="highlight">DB-PostgreSQL</span> フォルダを前提とします。
VSCodeでDB-PostgreSQLを開き、ターミナルはそのフォルダを作業ディレクトリにしてください。
</p>
<p>
まずはターミナルの作業場所とコンテナの起動状況を確認します。ここがズレると以降の作業がすべてズレるため、
最初に丁寧に確認しておきます。
</p>
<pre><code class="language-bash">
# VSCodeでプロジェクトを開いた状態で実行。PowerShell想定
pwd
</code></pre>
<p>出力が <span class="highlight">DB-PostgreSQL</span> 配下であることを確認してください。</p>
<div class="column">
  <div class="column-title">補足：演習環境の起動確認</div>
  <p class="column-note">
  まだコンテナが起動していない場合は、講義資料の手順に従って起動してください。
  </p>
</div>
<pre><code class="language-bash">
# Dockerコンテナ起動。講義資料の手順に従う
npm run db:up
</code></pre>
<pre><code class="language-bash">
# 起動確認
docker ps
</code></pre>
<pre><code class="language-bash">
mkdir -p /backup/base
mkdir -p /backup/wal_archive
</code></pre>

<h3>5.5 WALアーカイブ設定の確認</h3>
<p>
まずは現在の設定を確認します。設定ファイルを直接編集する場合は、操作権限と再起動が必要になるため注意してください。
</p>
<div class="column">
  <div class="column-title">Docker環境の設定ファイル編集 重要</div>
  <p class="column-note">
  Docker環境ではコンテナ内の <span class="highlight">/var/lib/postgresql/data/postgresql.conf</span> が本体設定。
  ただし、PITRの一時的な設定は <span class="highlight">postgresql.auto.conf</span> に追記する方が安全。
  例：設定追記 → 再起動、の順に行う。
  </p>
</div>
<pre><code class="language-bash">
# 例: postgresql.auto.conf へ追記。コンテナ内で実行
docker exec -it db-postgres bash -c "echo \"recovery_target_time = 'XXXX-XX-XX XX:XX:XX'\" &gt;&gt; /var/lib/postgresql/data/postgresql.auto.conf"
docker exec -it db-postgres bash -c "echo \"recovery_target_timeline = 'latest'\" &gt;&gt; /var/lib/postgresql/data/postgresql.auto.conf"
docker exec -it db-postgres bash -c "echo \"recovery_target_action = 'promote'\" &gt;&gt; /var/lib/postgresql/data/postgresql.auto.conf"
docker exec -it db-postgres bash -c "echo \"restore_command = 'cp /backup/wal_archive/%f %p'\" &gt;&gt; /var/lib/postgresql/data/postgresql.auto.conf"

# 例: 再起動で反映
docker restart db-postgres
</code></pre>
<p>
設定を変える前に、<span class="highlight">今の値を控える</span>ことは<span class="critical-text">必須</span>です。戻せなくなると原因調査が難しくなります。
</p>
<p>
SQLの実行は、講義資料どおりに <span class="highlight">VSCodeのタスク実行</span> または
<span class="highlight">ターミナルからnpm run sql</span> を使う。以下はターミナル実行の例。
</p>
<pre><code class="language-bash">
# 例: 一時ファイルを作ってSQLを実行
code sql/tmp_pitr.sql
npm run sql sql/tmp_pitr.sql
</code></pre>
<pre><code class="language-sql">
SHOW archive_mode;
SHOW archive_command;
SHOW wal_level;
</code></pre>

<p><span class="critical-text">以下は一般的な知識としての参考設定です。今回のDocker演習では、基本的に <code>postgresql.auto.conf</code> への追記のみで進め、<code>postgresql.conf</code> は直接変更しないでください。</span></p>
<p>postgresql.conf の代表的な設定例です。</p>
<pre><code class="language-ini">
archive_mode = on
archive_command = 'test ! -f /backup/wal_archive/%f &amp;&amp; cp %p /backup/wal_archive/%f'
wal_level = replica
</code></pre>
<div class="column">
  <div class="column-title">補足：archive_command が失敗する代表例</div>
  <p class="column-note">
  パスの存在・権限不足・同名ファイルの衝突が多い。`test ! -f` で上書きを防ぎつつ、
  実際にアーカイブ先にファイルが作成されているかを確認してください。
  </p>
</div>

<div class="column">
  <div class="column-title">演習：archive_command の失敗をどう切り分けますか？</div>
  <p class="column-note">
    パス、権限、既存ファイル衝突、ログ出力の4点を順に確認して、
    どこで失敗しているかを1つずつ切り分けてください。
  </p>
</div>
<div class="column">
  <div class="column-title">失敗時の観察ポイント（4.2で実施）</div>
  <p class="column-note">
    ここではあえて <code>restore_command</code> のパスを誤設定し、起動後にログを確認する練習をしておくと、
    実際の障害時に切り分けが速くなります。確認後は必ず正しいパスへ戻してください。
  </p>
</div>
<div class="column">
  <div class="column-title">参考質問例</div>
  <p class="column-note">
  「`archive_command` が失敗したときの切り分け手順を、①パス ②権限 ③既存ファイル衝突 ④ログ確認 の順で具体的に示してください。」
  </p>
</div>

<h3>5.6 ベースバックアップの取得</h3>
<p>ベースバックアップは復旧の起点です。まず取得してください。</p>
<pre><code class="language-bash">
pg_basebackup -D /backup/base -Fp -Xs -P
</code></pre>
<p>
<strong>-D</strong> は出力先、<strong>-Fp</strong> はプレーン形式、<strong>-Xs</strong> はWALのストリーミング取得、<strong>-P</strong> は進捗表示。
</p>

<h3>5.7 WAL生成とアーカイブ確認</h3>
<h4>5.7.1 テスト用テーブル作成</h4>
<pre><code class="language-sql">
CREATE TABLE pitr_demo (
  id SERIAL PRIMARY KEY,
  message TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
</code></pre>

<h4>5.7.2 変更を発生させる</h4>
<pre><code class="language-sql">
INSERT INTO pitr_demo (message) VALUES
  ('first'),
  ('second'),
  ('third');
</code></pre>

<h4>5.7.3 WALアーカイブの生成を促す</h4>
<pre><code class="language-sql">
SELECT pg_switch_wal();
</code></pre>

<h4>5.7.4 アーカイブ確認</h4>
<pre><code class="language-bash">
ls -la /backup/wal_archive
</code></pre>

<h3>5.8 障害発生の再現</h3>
<p>削除直前の時刻を記録してください。復旧ターゲットとして使用します。</p>
<pre><code class="language-sql">
SELECT now();
SELECT * FROM pitr_demo ORDER BY id;
</code></pre>

<p>誤操作として削除を実行。</p>
<pre><code class="language-sql">
DROP TABLE pitr_demo;
</code></pre>

<h3>5.9 PITRによる復旧</h3>
<h4>5.9.1 目標時刻の設定</h4>
<p>削除直前の時刻をメモして、その時刻へ復旧してください。</p>
<p><span class="critical-text">必ず先ほどメモした自分の時刻に書き換えてください。以下の日時をそのまま実行しないでください。</span></p>
<pre><code class="language-ini">
recovery_target_time = 'XXXX-XX-XX XX:XX:XX'
recovery_target_timeline = 'latest'
recovery_target_action = 'promote'
</code></pre>
<p>
<span class="highlight"><code>recovery_target_action = 'promote'</code></span> を指定しない場合は <code>pause</code> になるので、
復旧後に書き込みができない状態になります。<code>pause</code> のままにする場合は、
復旧後に次のSQLを実行して通常稼働へ移行します。
</p>
<pre><code class="language-sql">
SELECT pg_wal_replay_resume();
</code></pre>

<h4>5.9.2 リストア用の基本設定</h4>
<pre><code class="language-ini">
restore_command = 'cp /backup/wal_archive/%f %p'
</code></pre>
<p>
ここでパスを間違えると、<span class="highlight">エラーメッセージが表示されないまま処理が停滞する</span>ことがあります。ログ確認を必ずセットで実施してください。
</p>
<div class="column">
  <div class="column-title">原因理解</div>
  <p class="column-note">
    学習時は、あえて誤ったパスで一度起動し、<code>docker logs db-postgres</code> で症状を確認してから正しい設定に戻すと、
    復旧停滞時の見え方を具体的に理解できます。
  </p>
</div>

<h4>5.9.3 復旧シグナルの用意</h4>
<pre><code class="language-bash">
touch recovery.signal
</code></pre>
<p>
Docker環境では <span class="highlight">/var/lib/postgresql/data</span> に作成します。例：
<span class="highlight">docker exec -it db-postgres bash -c "touch /var/lib/postgresql/data/recovery.signal"</span>
</p>
<p>
このコマンドは <span class="highlight">コンテナが起動している状態</span>で実行する必要があります。
実行直後に <span class="highlight">docker restart db-postgres</span> を行う流れにすると迷いにくいです。
</p>
<pre><code class="language-sql">
-- 復旧後に pause 状態の場合のみ実行
SELECT pg_wal_replay_resume();
</code></pre>
<div class="column">
  <div class="column-title">順序の確認 重要</div>
  <p class="column-note">
  1) <span class="highlight">設定ファイルを反映</span>。postgresql.auto.conf へ追記 →
  2) <span class="highlight">recovery.signal を作成</span> →
  3) <span class="highlight">サーバー起動</span>。コンテナ start
  この順序が崩れると、<span class="critical-text">設定が反映されないまま起動して復旧が進まない</span>ことがある。
  </p>
</div>

<h4>5.9.4 復旧後の確認</h4>
<pre><code class="language-sql">
SELECT * FROM pitr_demo ORDER BY id;
</code></pre>

<h4>5.9.5 復旧状況の監視コマンド</h4>
<pre><code class="language-sql">
-- 復旧中かどうか
SELECT pg_is_in_recovery();

-- 受信済み/再生済みのWAL位置
SELECT pg_last_wal_receive_lsn();
SELECT pg_last_wal_replay_lsn();

-- 最後に再生したトランザクション時刻
SELECT pg_last_xact_replay_timestamp();
</code></pre>

<h3>定着確認（第5章）</h3>
<ul>
  <li><span class="masked">restore_command</span> の設定ミスは<span class="masked">復旧停止</span>の原因になりやすい。</li>
  <li>復旧手順では <span class="masked">設定反映 → recovery.signal作成 → 起動</span> の順序を守る。</li>
  <li>復旧状態の確認には <span class="masked">pg_is_in_recovery()</span> を使う。</li>
</ul>

<h2>6. 注意点</h2>
<ul>
  <li>アーカイブ先のパスと権限を確認する。</li>
  <li><code>archive_command</code> の成否をログで確認する。</li>
  <li><code>recovery_target_time</code> の形式を確認する。</li>
  <li>ベースバックアップ取得後のWAL欠落有無を確認する。</li>
  <li>復旧後に起動が完了しない場合はターゲット時刻到達を確認する。</li>
  <li>復旧後にアプリが動かない場合は<span class="highlight">接続先が旧DBのまま</span>でないか確認する。</li>
</ul>

<h3>6.1 WALの掃除</h3>
<p>
WALアーカイブを溜め続けるとディスクが溢れます。古いWALを削除する場合は
<code>pg_archivecleanup</code> の利用を検討してください。
</p>
<pre><code class="language-bash">
# 例: 古いWALを削除。最新のWALファイルを基準に
pg_archivecleanup /backup/wal_archive 0000000100000000000000A3
</code></pre>

<div class="column">
  <div class="column-title">演習：WAL削除の安全条件を説明してください</div>
  <p class="column-note">
    「どのベースバックアップに対して、どの時点まで復旧する可能性があるか」を先に決めると、
    消してよいWALの範囲を説明しやすくなります。
  </p>
</div>

<h3>定着確認（第6章）</h3>
<ul>
  <li><span class="masked">archive_command</span> の異常時は <span class="masked">パス・権限・既存ファイル衝突・ログ</span> の順で確認する。</li>
  <li>WAL削除前には <span class="masked">復旧可能範囲</span> を先に定義する。</li>
  <li>復旧後に不整合がある場合は <span class="masked">接続先誤りやWAL欠落</span> を疑う。</li>
</ul>

<h2>7. SQLドリル / 演習の準備</h2>
<p>
本演習は、<code>from-teacher/10/create-x_db.sql</code> で定義される実スキーマ（<code>x_jobs</code> / <code>x_characters</code> / <code>x_guilds</code> / <code>x_guild_characters</code> / <code>x_items</code> / <code>x_character_items</code> / <code>x_gold_transfers</code>）を前提に進めます。
本章では、誤操作を意図的に発生させ、PITRで戻す手順を確認します。
</p>

<div class="column">
  <div class="column-title">ER図（create-x_db.sql対応）</div>
  <p class="column-note">
    以下は <code>from-teacher/10/create-x_db.sql</code> に対応するER図です。ドリル前にテーブル関連を確認してください。
  </p>
  <img src="../images/LER-01.png" alt="create-x_db.sql のER図" />
</div>

<div class="column">
  <div class="column-title">解答例の場所</div>
  <p class="column-note">
    各演習の解答は <a href="#answers">第9章「演習の解答例」</a> にまとめています。
    第9章には、各問題について <span class="highlight">コマンド例</span> と <span class="highlight">SQL解答例</span> の両方を掲載しています。
  </p>
</div>

<div class="column">
  <div class="column-title">演習環境の再構築</div>
  <p class="column-note">
    演習結果で状態が不明になった場合は、次のコマンドでスキーマを再作成してください。
  </p>
  <pre><code class="language-bash">
npm run sql from-teacher/10/create-x_db.sql
  </code></pre>
</div>

<div class="column">
  <div class="column-title">最小データの投入（ドリル実行前）</div>
  <p class="column-note">
    <code>create-x_db.sql</code> はテーブル定義が中心です。<span class="highlight">実行直後はテーブルが空のため、ドリル検証用の初期データをここで作成します。</span>
    以下の最小データを入れてからドリルを実施してください。
  </p>
  <pre><code class="language-sql">
INSERT INTO x_jobs (name, attack_gain, defense_gain, magic_gain)
VALUES
  ('warrior', 3, 2, 0),
  ('mage', 0, 1, 4)
ON CONFLICT (name) DO NOTHING;

INSERT INTO x_characters (name, level, job_id)
SELECT 'Alice', 20, j.job_id FROM x_jobs j WHERE j.name = 'warrior'
UNION ALL
SELECT 'Bob', 18, j.job_id FROM x_jobs j WHERE j.name = 'mage'
UNION ALL
SELECT 'Celine', 12, j.job_id FROM x_jobs j WHERE j.name = 'warrior';

INSERT INTO x_guilds (name, owner_id)
SELECT 'Alpha', c.character_id
FROM x_characters c
WHERE c.name = 'Alice'
ON CONFLICT (name) DO NOTHING;

INSERT INTO x_guild_characters (guild_id, character_id)
SELECT g.guild_id, c.character_id
FROM x_guilds g
JOIN x_characters c ON g.name = 'Alpha'
WHERE c.name IN ('Alice', 'Bob')
ON CONFLICT DO NOTHING;
  </code></pre>
</div>

<div class="column">
  <div class="column-title">時刻特定の書き方</div>
  <p class="column-note">
    復旧時刻は、<code>SELECT now();</code> でメモした値を使います。手順書ではプレースホルダとして <code>XXXX-XX-XX XX:XX:XX</code> を使います。
    例として「2026年2月23日 0時00分」を指定する場合は <code>recovery_target_time = '2026-02-23 00:00:00'</code> と書きます。
  </p>
</div>

<h2>8. SQLドリル</h2>

<h3>ex-03_1：WHERE句漏れで論理削除フラグを全件更新</h3>
<p>
特定キャラクタだけを論理削除する予定が、<code>WHERE</code> を書き忘れて全件に <code>deleted_at</code> を設定してしまう事故を再現します。
</p>
<pre><code class="language-sql">
SELECT now();

BEGIN;
UPDATE x_characters
SET deleted_at = LOCALTIMESTAMP(0);
COMMIT;
</code></pre>

<h3>ex-03_2：運営配布INSERTの二重実行</h3>
<p>
運営配布（システム→キャラクタ）を誤って2回実行し、<code>x_gold_transfers</code> に重複履歴を作るケースです。
</p>
<pre><code class="language-sql">
SELECT now();

BEGIN;
INSERT INTO x_gold_transfers (from_character_id, to_character_id, amount, transferred_at)
SELECT NULL, character_id, 1000, LOCALTIMESTAMP(0)
FROM x_characters
WHERE deleted_at IS NULL;
COMMIT;

-- 同じ処理をもう1回実行して誤りを再現
BEGIN;
INSERT INTO x_gold_transfers (from_character_id, to_character_id, amount, transferred_at)
SELECT NULL, character_id, 1000, LOCALTIMESTAMP(0)
FROM x_characters
WHERE deleted_at IS NULL;
COMMIT;
</code></pre>

<h3>ex-03_3：所属テーブルの物理削除</h3>
<p>
特定キャラクタの所属だけ外すつもりが、誤った条件で削除してしまう事故を再現します。
</p>
<pre><code class="language-sql">
SELECT now();

BEGIN;
DELETE FROM x_guild_characters
WHERE character_id IN (
  SELECT character_id FROM x_characters WHERE name IN ('Alice', 'Bob')
);
COMMIT;
</code></pre>

<h3>ex-03_4：<code>x_guilds</code> テーブルの誤削除</h3>
<p>
作業用テーブルを削除するつもりで、誤って本表を削除するケースです。
</p>
<pre><code class="language-sql">
SELECT now();

DROP TABLE x_guilds;
</code></pre>

<h3>ex-03_5：レベル更新ロジックの誤適用</h3>
<p>
一部キャラクタだけの調整のつもりが、全員を上限レベルへ更新してしまうケースです。
</p>
<pre><code class="language-sql">
SELECT now();

BEGIN;
UPDATE x_characters
SET level = 255
WHERE deleted_at IS NULL;
COMMIT;
</code></pre>

<h3>ex-03_6：送金履歴の全削除</h3>
<p>
絞り込み削除のつもりが、履歴全体を消してしまうケースです。
</p>
<pre><code class="language-sql">
SELECT now();

BEGIN;
DELETE FROM x_gold_transfers;
COMMIT;
</code></pre>

<h2 id="answers">9. 演習の解答例</h2>
<p>
本章では、各ドリルに対して <span class="highlight">コマンド例</span> と <span class="highlight">SQL解答例</span> を必ず示します。
時刻は <code>XXXX-XX-XX XX:XX:XX</code> をプレースホルダとして記述し、具体例として <code>2026-02-23 00:00:00</code> も併記します。
</p>

<details>
<summary>共通リカバリ・テンプレート（コマンド + SQL）</summary>
<pre><code class="language-bash">
# 1) 復旧時刻を設定（プレースホルダ）
docker exec -it db-postgres bash -c "echo \"restore_command = 'cp /backup/wal_archive/%f %p'\" >> /var/lib/postgresql/data/postgresql.auto.conf"
docker exec -it db-postgres bash -c "echo \"recovery_target_time = 'XXXX-XX-XX XX:XX:XX'\" >> /var/lib/postgresql/data/postgresql.auto.conf"
docker exec -it db-postgres bash -c "echo \"recovery_target_timeline = 'latest'\" >> /var/lib/postgresql/data/postgresql.auto.conf"
docker exec -it db-postgres bash -c "echo \"recovery_target_action = 'pause'\" >> /var/lib/postgresql/data/postgresql.auto.conf"

# 2) 具体例（2026年2月23日 0時00分）
docker exec -it db-postgres bash -c "echo \"recovery_target_time = '2026-02-23 00:00:00'\" >> /var/lib/postgresql/data/postgresql.auto.conf"

# 3) recovery.signal の作成と再起動
docker exec -it db-postgres bash -c "touch /var/lib/postgresql/data/recovery.signal"
docker restart db-postgres
  </code></pre>
<pre><code class="language-sql">
-- 復旧確認SQL
SELECT pg_is_in_recovery();
SELECT pg_last_xact_replay_timestamp();

-- pause の場合のみ通常稼働へ移行
SELECT pg_wal_replay_resume();
  </code></pre>
</details>

<h3>ex-03_1 の解答例</h3>
<details>
  <summary>WHERE句漏れで deleted_at を全件更新した場合</summary>
  <pre><code class="language-bash">
# 復旧時刻を「誤UPDATE直前」に設定
docker exec -it db-postgres bash -c "echo \"recovery_target_time = 'XXXX-XX-XX XX:XX:XX'\" >> /var/lib/postgresql/data/postgresql.auto.conf"
docker restart db-postgres
  </code></pre>
  <pre><code class="language-sql">
-- 具体例: 2026/02/23 00:00:00 を使う場合
-- recovery_target_time = '2026-02-23 00:00:00'

-- 検証
SELECT character_id, name, deleted_at
FROM x_characters
ORDER BY character_id;
  </code></pre>
</details>

<h3>ex-03_2 の解答例</h3>
<details>
  <summary>運営配布INSERTを二重実行した場合</summary>
  <pre><code class="language-bash">
# 2回目INSERT直前の時刻へ戻す
docker exec -it db-postgres bash -c "echo \"recovery_target_time = 'XXXX-XX-XX XX:XX:XX'\" >> /var/lib/postgresql/data/postgresql.auto.conf"
docker restart db-postgres
  </code></pre>
  <pre><code class="language-sql">
-- 検証: 同一amountの重複が解消されているか確認
SELECT to_character_id, amount, COUNT(*)
FROM x_gold_transfers
GROUP BY to_character_id, amount
ORDER BY to_character_id, amount;
  </code></pre>
</details>

<h3>ex-03_3 の解答例</h3>
<details>
  <summary>x_guild_characters を誤削除した場合</summary>
  <pre><code class="language-bash">
# DELETE直前の時刻へ戻す
docker exec -it db-postgres bash -c "echo \"recovery_target_time = 'XXXX-XX-XX XX:XX:XX'\" >> /var/lib/postgresql/data/postgresql.auto.conf"
docker restart db-postgres
  </code></pre>
  <pre><code class="language-sql">
-- 検証: Alice/Bob の所属が復活しているか
SELECT gc.guild_id, gc.character_id, c.name
FROM x_guild_characters gc
JOIN x_characters c ON c.character_id = gc.character_id
WHERE c.name IN ('Alice', 'Bob')
ORDER BY gc.guild_id, gc.character_id;
  </code></pre>
</details>

<h3>ex-03_4 の解答例</h3>
<details>
  <summary>DROP TABLE x_guilds の復旧</summary>
  <pre><code class="language-bash">
# DROP実行直前へ戻す
docker exec -it db-postgres bash -c "echo \"recovery_target_time = 'XXXX-XX-XX XX:XX:XX'\" >> /var/lib/postgresql/data/postgresql.auto.conf"
docker restart db-postgres
  </code></pre>
  <pre><code class="language-sql">
-- 検証: テーブルとデータが存在するか
\dt x_guilds
SELECT COUNT(*) FROM x_guilds;
  </code></pre>
</details>

<h3>ex-03_5 の解答例</h3>
<details>
  <summary>level を全件255へ更新した場合</summary>
  <pre><code class="language-bash">
# UPDATE直前へ戻す
docker exec -it db-postgres bash -c "echo \"recovery_target_time = 'XXXX-XX-XX XX:XX:XX'\" >> /var/lib/postgresql/data/postgresql.auto.conf"
docker restart db-postgres
  </code></pre>
  <pre><code class="language-sql">
-- 検証: レベル分布が元に戻っているか
SELECT level, COUNT(*)
FROM x_characters
GROUP BY level
ORDER BY level;
  </code></pre>
</details>

<h3>ex-03_6 の解答例</h3>
<details>
  <summary>x_gold_transfers を全削除した場合</summary>
  <pre><code class="language-bash">
# DELETE直前へ戻す
docker exec -it db-postgres bash -c "echo \"recovery_target_time = 'XXXX-XX-XX XX:XX:XX'\" >> /var/lib/postgresql/data/postgresql.auto.conf"
docker restart db-postgres
  </code></pre>
  <pre><code class="language-sql">
-- 検証: 履歴件数が0以外に戻っているか
SELECT COUNT(*) AS transfer_count
FROM x_gold_transfers;
  </code></pre>
</details>

<hr>

<h3>まとめと復習</h3>
<p>
本講義の要点を復習する。黄色部分をクリックすると正解が表示される。
</p>
<ul>
  <li>PITRを実現するには、ベースバックアップと <span class="masked">WALアーカイブ</span> の両方が必須です。</li>
  <li>リカバリを開始するには、データディレクトリ内に <span class="masked">recovery.signal</span> という空ファイルを作成します。</li>
  <li>復旧を止めたい特定の時刻は <span class="masked">recovery_target_time</span> パラメータで指定します。</li>
  <li>リカバリ終了直後、DBは「一時停止」状態になるため、<span class="masked">pg_wal_replay_resume()</span> を実行して通常稼働へ移行させる必要があります。</li>
  <li>物理的な破壊（DROP TABLEなど）は、通常の <span class="masked">ROLLBACK</span> では救済できないため、PITRが有効です。</li>
</ul>

<div class="column">
  <div class="column-title">最終演習：PITR手順を3分で説明してください</div>
  <p class="column-note">
    「起点（ベースバックアップ）」「履歴（WAL）」「停止条件（recovery_target）」の3要素を順番に説明すると、
    実務でも共有しやすい説明になります。
  </p>
</div>


<p class="footer-text"><span class="highlight">制作時間：22時間</span></p>
<footer class="footer">
  <a class="footer-link" href="https://github.com/Tsubasa213" target="_blank" rel="noopener noreferrer">GitHub</a>
  <p class="footer-text">© copyright 2026 Tsubasa213/つばさ all right resolved.</p>
</footer>

</body>
<script src="main.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
<iframe
  src="https://docsbot.ai/iframe/4dWqauk5JhWuOOyVaU35/LcmBqB48fmMf6m6LgGL1"
  frameborder="0"
  scrolling="no"
  class="docsbot-frame">
</iframe>
</html>


<!-- https://qiita.com/yaju/items/51e7b1037a99856e547c　めも -->