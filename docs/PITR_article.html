<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="style.css">
  <title>Point In Time Recoveryの実践</title>
</head>
<body class="markdown-body">

<header class="header">
  <h2 class="site-title">DB技術記事</h2>
  <button class="menu-btn" id="menuBtn">☰</button>
</header>

<h1>PostgreSQLにおけるPoint In Time Recoveryの実践</h1>

<h2>1. はじめに（想定読者と学習ゴール）</h2>
<p>
この講義では<span class="highlight">SQL実行</span>、<span class="highlight">トランザクション</span>、<span class="highlight">結合</span>、<span class="highlight">バックアップ/リストア</span>の基礎を理解している前提で解説する。
</p>
<p>
学習ゴールは次の3つ：①<span class="highlight">PITRの構成要素</span>を説明できる、②演習環境で<span class="highlight">PITRを再現</span>できる、③失敗時に原因を切り分けられる。手を動かすハンズオンと、定着確認・SQLドリルで最低90分以上の学習体験になる分量で進める。
</p>

<h2>2. 演習環境の前提（共通設定の確認）</h2>
<ul>
  <li>PostgreSQL 17（Docker）</li>
  <li>授業提供の演習用コンテナ環境</li>
  <li>PowerShell / bash どちらでも可</li>
</ul>
<p>
本講義資料のリンク：<a href="https://takeshiwada1980.github.io/DB-2025/">DB-2025 講義資料 Index</a>
</p>
<p>
第12回講義のバックアップ/リストアの内容を復習してから進むとスムーズ：
<a href="https://takeshiwada1980.github.io/DB-2025/lecture12.html#%E3%83%90%E3%83%83%E3%82%AF%E3%82%A2%E3%83%83%E3%83%97%E3%81%A8%E3%83%AA%E3%82%B9%E3%83%88%E3%82%A2">第12回講義（バックアップとリストア）</a>
</p>

<h2>3. PITRの全体像（深く理解する）</h2>
<p>
PITRは「<span class="highlight">ベースバックアップ</span> + <span class="highlight">WALアーカイブ</span> + <span class="highlight">復旧設定</span>」の組み合わせで成立する。ベースバックアップはある時点の完全コピー、WALはそれ以降の更新履歴。復旧時に「どこまで戻すか（時点）」を指定する。
</p>
<ul>
  <li>ベースバックアップ：DB全体のスナップショット</li>
  <li>WALアーカイブ：更新履歴（Write-Ahead Logging）</li>
  <li>復旧設定：restore_command と recovery_target_time</li>
</ul>

<h3>3.1 PITRを使う利点（なぜ必要か）</h3>
<p>
PITRの最大の利点は「<span class="highlight">特定時点への巻き戻し</span>」ができることだ。たとえば誤ってテーブルを削除した場合でも、削除直前の時点に復旧できる。
これは単純なダンプ復元だけでは再現できない、時点指定の復旧という強みになる。
</p>
<ul>
  <li>誤操作（DROP/UPDATE/DELETE）の直前に戻せる</li>
  <li>障害発生時の復旧範囲を最小化できる</li>
  <li>「バックアップはあるが直近データが必要」の状況に強い</li>
</ul>
<div class="column">
  <div class="column-title">コラム：トランザクション処理だけじゃダメなのか？</div>
  <p class="column-note">
  トランザクションは「その処理の中で失敗した場合に元に戻す」仕組み。誤操作が<strong>コミット済み</strong>だったり、
  既にアプリが落ちてしまった後だと、トランザクションでは戻せない。PITRは「処理が終わってしまった後」にも
  時点指定で巻き戻せるのが決定的な違い。
  </p>
</div>

<h3>3.2 WALの仕組み（なぜ巻き戻れるのか）</h3>
<p>
WALは「<span class="highlight">先にログを書いてから実データを更新する</span>」仕組み。これにより、障害発生時でもログを再生すれば同じ状態を再現できる。
PITRはこのWALを時系列で適用し、指定時刻で止めることで「その時点のDB」を作る。
</p>
<ul>
  <li>WALは更新の順番を保証する</li>
  <li>アーカイブは「WALを退避して保管する」こと</li>
  <li>WALが欠落すると、その区間は復旧できない</li>
</ul>
<div class="column">
  <div class="column-title">補足：WALは「戻す」ためのログ？</div>
  <p class="column-note">
  WALは基本的に「前に進めるためのログ（REDO）」として使われる。PITRはWALを順に再生し、
  指定時刻で止めることで結果的に「戻したように見せる」仕組みだ。
  </p>
</div>
<div class="column">
  <div class="column-title">AIへのプロンプト例</div>
  <p class="column-note">
  「WAL が REDO ログである理由を、障害復旧の観点で具体例つきで説明してください。」
  </p>
</div>

<h3>3.3 ベースバックアップの役割（起点の重要性）</h3>
<p>
WALだけでは復旧できない。必ず「<span class="highlight">起点となるスナップショット</span>（ベースバックアップ）」が必要になる。
たとえば、WALは「差分」なので、どこかの時点の完全コピーがないと復元先が存在しない。
</p>

<h3>3.4 復旧ターゲットの種類</h3>
<p>
PITRは時刻以外にも「<span class="highlight">どこで止めるか</span>」を指定できる。用途に応じて選ぶと面白い。
</p>
<ul>
  <li>recovery_target_time：時刻指定（最も直感的）</li>
  <li>recovery_target_lsn：LSN指定（より厳密）</li>
  <li>recovery_target_name：リカバリーポイント名指定</li>
</ul>
<div class="column">
  <div class="column-title">補足：LSNって何？</div>
  <p class="column-note">
  LSN（Log Sequence Number）はWALの位置を表す番号。時刻よりも厳密に位置を指定できるため、
  監査や再現性が重視されるケースで有効。
  </p>
</div>
<div class="column">
  <div class="column-title">AIへのプロンプト例</div>
  <p class="column-note">
  「PostgreSQL の LSN とは何か。PITR で使う理由を短く説明してください。」
  </p>
</div>

<h3>3.5 「ダンプ復元」との違い</h3>
<p>
pg_dump + psql の復元は「その時点の状態に戻す」だけで、時点指定ができない。
PITRは「誤操作直前」など細かい時点に戻せる点が大きな違い。
</p>

<h3>3.6 運用での考え方（RPOとRTO）</h3>
<p>
PITRは運用設計とセットで考えると理解が深まる。<span class="highlight">RPO</span>（失ってよい最大時間）と<span class="highlight">RTO</span>（復旧に許される時間）を意識すると、
どの頻度でバックアップし、どれだけWALを保存すべきか判断できる。
</p>
<ul>
  <li>RPOが短いほどWAL欠落が許されない</li>
  <li>RTOが短いほど復旧手順の自動化が必要</li>
</ul>
<h3>3.7 ストーリーで理解するPITR（事故対応の1日）</h3>
<p>
午前中の運用作業で、担当者が間違えて重要テーブルを削除してしまったとする。監視にはエラーが上がり、
ユーザから「データが消えた」と連絡が入った。ここで求められるのは、<span class="highlight">直前の時点に戻す</span>こと。
PITRはこの状況で最短復旧を実現するための選択肢になる。
</p>
<ol>
  <li>「いつ消えたか」を時刻で確定する</li>
  <li>ベースバックアップとWALアーカイブを確認</li>
  <li>復旧ターゲットを設定して再起動</li>
  <li>テーブルの整合性を検証し、業務を再開</li>
</ol>
<div class="column">
  <div class="column-title">現場メモ：時刻の確定が最重要</div>
  <p class="column-note">
  「消えた瞬間の時刻」が曖昧だと、復旧の止めどころが分からない。監査ログやアプリログと照らし合わせ、
  1分単位で時刻を確定する。
  </p>
</div>

<h3>3.8 失敗しやすいパターンと回避策</h3>
<ul>
  <li>WALアーカイブの保存先が満杯 → <span class="highlight">容量監視</span>とローテーションを設計する</li>
  <li>ベースバックアップの世代が古すぎる → <span class="highlight">定期取得</span>を必須化する</li>
  <li>復旧ターゲット時刻が未来 → <span class="highlight">ログ時刻と整合</span>をとる</li>
  <li>復旧後に書き込みできない → <span class="highlight">recovery.signalの撤去</span>を確認する</li>
</ul>

<h3>3.9 時系列で見るPITR（流れの見える化）</h3>
<p>
「ベース → WAL適用 → ターゲット停止」という流れを頭の中で一直線に描けると理解が進む。
</p>
<ol>
  <li>ベースバックアップ取得（時刻A）</li>
  <li>WALアーカイブが蓄積（A〜B）</li>
  <li>障害発生（時刻B）</li>
  <li>復旧ターゲット（時刻B直前）で停止</li>
</ol>
<div class="column">
  <div class="column-title">AIへのプロンプト例</div>
  <p class="column-note">
  「PITRの流れを『時系列の出来事』として説明してください。1分で読める長さで。」
  </p>
</div>

<h2>4. ハンズオン学習</h2>
<h3>4.1 作業用ディレクトリの準備</h3>
<p>バックアップ先とアーカイブ先を明示的に作成する。</p>
<p>
このハンズオンは、講義資料どおりに構築済みの <span class="highlight">DB-PostgreSQL</span> フォルダを前提とする。
VSCodeでDB-PostgreSQLを開き、ターミナルはそのフォルダを作業ディレクトリにする。
</p>
<p>
まずはターミナルの作業場所とコンテナの起動状況を確認する。ここがズレると以降の作業が全部ずれるので、
最初に丁寧に確認しておく。
</p>
<pre><code>
# VSCodeでプロジェクトを開いた状態で実行（PowerShell想定）
pwd
</code></pre>
<p>出力が <span class="highlight">DB-PostgreSQL</span> 配下であることを確認する。</p>
<div class="column">
  <div class="column-title">補足：演習環境の起動確認</div>
  <p class="column-note">
  まだコンテナが起動していない場合は、講義資料の手順に従って起動する。
  </p>
</div>
<pre><code>
# Dockerコンテナ起動（講義資料の手順）
npm run db:up
</code></pre>
<pre><code>
# 起動確認（例）
docker ps
</code></pre>
<pre><code>
mkdir -p /backup/base
mkdir -p /backup/wal_archive
</code></pre>

<h3>4.2 WALアーカイブ設定の確認</h3>
<p>
まずは現在の設定を確認する。設定ファイルを直接編集する場合は、操作権限と再起動が必要になるので注意する。
</p>
<p>
SQLの実行は、講義資料どおりに <span class="highlight">VSCodeのタスク実行（Ctrl+Shift+B）</span> または
<span class="highlight">ターミナルからnpm run sql</span> を使う。以下はターミナル実行の例。
</p>
<pre><code>
# 例: 一時ファイルを作ってSQLを実行
code sql/tmp_pitr.sql
npm run sql sql/tmp_pitr.sql
</code></pre>
<pre><code>
SHOW archive_mode;
SHOW archive_command;
SHOW wal_level;
</code></pre>

<p>postgresql.conf の代表的な設定例（環境に合わせて調整）。</p>
<pre><code>
archive_mode = on
archive_command = 'test ! -f /backup/wal_archive/%f &amp;&amp; cp %p /backup/wal_archive/%f'
wal_level = replica
</code></pre>
<div class="column">
  <div class="column-title">補足：archive_command が失敗する代表例</div>
  <p class="column-note">
  パスの存在・権限不足・同名ファイルの衝突が多い。`test ! -f` で上書きを防ぎつつ、
  実際にアーカイブ先にファイルが作成されているか確認すること。
  </p>
</div>
<div class="column">
  <div class="column-title">AIへのプロンプト例</div>
  <p class="column-note">
  「archive_command が失敗する典型例と、確認すべきログの場所を教えてください。」
  </p>
</div>

<h3>4.3 ベースバックアップの取得</h3>
<p>ベースバックアップは復旧の起点になる。まずは取得しておく。</p>
<pre><code>
pg_basebackup -D /backup/base -Fp -Xs -P
</code></pre>
<p>
<strong>-D</strong> は出力先、<strong>-Fp</strong> はプレーン形式、<strong>-Xs</strong> はWALのストリーミング取得、<strong>-P</strong> は進捗表示。
</p>

<h3>4.4 WAL生成とアーカイブ確認</h3>
<h4>4.4.1 テスト用テーブル作成</h4>
<pre><code>
CREATE TABLE pitr_demo (
  id SERIAL PRIMARY KEY,
  message TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
</code></pre>

<h4>4.4.2 変更を発生させる</h4>
<pre><code>
INSERT INTO pitr_demo (message) VALUES
  ('first'),
  ('second'),
  ('third');
</code></pre>

<h4>4.4.3 WALアーカイブの生成を促す</h4>
<pre><code>
SELECT pg_switch_wal();
</code></pre>

<h4>4.4.4 アーカイブ確認</h4>
<pre><code>
ls -la /backup/wal_archive
</code></pre>

<h3>4.5 障害発生の再現</h3>
<p>削除直前の時刻を記録しておく（復旧ターゲットになる）。</p>
<pre><code>
SELECT now();
SELECT * FROM pitr_demo ORDER BY id;
</code></pre>

<p>誤操作（削除）を実行。</p>
<pre><code>
DROP TABLE pitr_demo;
</code></pre>

<h3>4.6 PITRによる復旧</h3>
<h4>4.6.1 目標時刻の設定</h4>
<p>削除直前の時刻をメモして、その時刻へ復旧する。</p>
<pre><code>
recovery_target_time = '2026-01-27 10:30:00'
</code></pre>

<h4>4.6.2 リストア用の基本設定</h4>
<pre><code>
restore_command = 'cp /backup/wal_archive/%f %p'
</code></pre>

<h4>4.6.3 復旧シグナルの用意</h4>
<pre><code>
touch recovery.signal
</code></pre>

<h4>4.6.4 復旧後の確認</h4>
<pre><code>
SELECT * FROM pitr_demo ORDER BY id;
</code></pre>

<h2>5. つまずきやすい点（チェックリスト）</h2>
<ul>
  <li>アーカイブ先のパスが存在しない／権限がない</li>
  <li>archive_command が失敗している（ログで確認）</li>
  <li>recovery_target_time の形式ミス</li>
  <li>ベースバックアップ取得後にWALが欠落している</li>
  <li>復旧後の起動が終了しない（ターゲット時刻未到達）</li>
</ul>

<h2>6. 定着確認</h2>
<ol>
  <li>ベースバックアップは<span class="masked">起点となる完全コピー</span>、WALアーカイブは<span class="masked">更新履歴の保管</span>を表す。</li>
  <li><span class="masked">pg_basebackup</span>はDB全体のスナップショットを取得する。</li>
  <li>archive_command が失敗した場合は<span class="masked">PostgreSQLログ</span>と<span class="masked">アーカイブ先の権限/パス</span>を確認する。</li>
  <li>recovery_target_time は<span class="masked">復旧を止める時点</span>を指定するために使う。</li>
  <li>復旧後に動作不良があれば、まず<span class="masked">WAL欠落の有無</span>を確認する。</li>
  <li>WALは基本的に<span class="masked">REDOログ</span>として機能する。</li>
  <li>PITRはWALを<span class="masked">時系列に適用</span>し、指定時刻で停止する。</li>
  <li>RPOは<span class="masked">失ってよい最大時間</span>、RTOは<span class="masked">復旧に許される時間</span>を指す。</li>
  <li>LSNは<span class="masked">WALの位置</span>を表す番号である。</li>
  <li>ベースバックアップが古すぎると<span class="masked">復旧時間が長くなる</span>。</li>
  <li>WAL保存先が満杯だと<span class="masked">アーカイブが停止</span>する。</li>
  <li>復旧ターゲット時刻は<span class="masked">ログ時刻と整合</span>を取る必要がある。</li>
  <li>復旧後に書き込みできない場合は<span class="masked">recovery.signal</span>を確認する。</li>
  <li>PITRは<span class="masked">時点指定の復旧</span>が最大の強みである。</li>
  <li>監査対応では<span class="masked">LSN指定</span>が有効な場合がある。</li>
</ol>

<h2>7. SQLドリル / 演習</h2>
<p>
ここからは <span class="highlight">x_**** テーブル群</span>を使った実務寄りのSQLドリル。必ず <span class="highlight">START TRANSACTION</span> と <span class="highlight">ROLLBACK</span> で囲んで実行すること。
</p>

<h3>ex-03_1：年始の一斉支給（運営→全キャラ）</h3>
<p><span class="highlight">難易度：★★★</span></p>
<p>
新年イベントとして、運営から全キャラへ 25,000G〜45,000G を 1,000G 刻みのランダム値で支給する送金レコードを <span class="highlight">x_gold_transfers</span> に挿入せよ。
論理削除済みキャラは除外し、<span class="highlight">transferred_at</span> は 2026-01-01 04:00:00 とする。
</p>
<p><span class="highlight">ヒント</span>：乱数生成（第09回講義）、`FLOOR(RANDOM() * n)`、`DATE/TIMESTAMP` の扱い。</p>
<pre><code>
-- 期待する出力イメージ（例）
--    id    | from  |   to    |  amount  |   transferred_at
-- ---------+-------+---------+----------+---------------------
--  xxxxxxxx | _SYS_ | Marvin  |   30,000 | 2026-01-01 04:00:00
--  xxxxxxxx | _SYS_ | Zach    |   38,000 | 2026-01-01 04:00:00
</code></pre>

<h3>ex-03_2：ギルド共益費の自動徴収</h3>
<p><span class="highlight">難易度：★★★★</span></p>
<p>
各ギルドで、メンバからオーナーへ「共益費」2,000Gを支払う送金レコードを作成せよ。
<span class="highlight">論理削除済みキャラは除外</span>し、オーナー本人は自分のギルドへ支払わない。
transferred_at は 2025-12-15 04:00:00 固定とする。
</p>
<p><span class="highlight">ヒント</span>：x_guilds、x_guild_characters、x_characters の結合、オーナーIDの取得。</p>
<pre><code>
-- 期待する出力イメージ（例）
--    id    |  from  |   to   |  amount  |   transferred_at
-- ---------+--------+--------+----------+---------------------
--  xxxxxxxx | Alice  | Marvin |    2,000 | 2025-12-15 04:00:00
--  xxxxxxxx | Oscar  | Bob    |    2,000 | 2025-12-15 04:00:00
</code></pre>

<h3>ex-03_3：新規作成キャラへの初期資金配布</h3>
<p><span class="highlight">難易度：★★★</span></p>
<p>
運営から各キャラへ 1,000G を支給する送金レコードを作成せよ。
論理削除済みのキャラも含める。<span class="highlight">transferred_at は created_at の5分後</span>にすること。
</p>
<p><span class="highlight">ヒント</span>：`INTERVAL` の加算、TIMESTAMP演算。</p>
<pre><code>
-- 期待する出力イメージ（例）
--    id    | from  |   to    |  amount  |   transferred_at
-- ---------+-------+---------+----------+---------------------
</code></pre>

<footer class="footer">
  <a class="footer-link" href="https://github.com/Tsubasa213" target="_blank" rel="noopener noreferrer">GitHub</a>
  <p class="footer-text">© copyright 2026 Tsubasa213/つばさ all right resolved.</p>
</footer>

</body>
<script src="main.js"></script>
</html>
