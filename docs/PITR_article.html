<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github-dark.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
  <link rel="stylesheet" href="style.css">
  <title>Point In Time Recoveryの実践</title>
</head>
<body class="markdown-body">

<header class="header">
  <h2 class="site-title">DB技術記事</h2>
  <button class="menu-btn" id="menuBtn">☰</button>
</header>

<h1>PostgreSQLにおけるPoint In Time Recoveryの実践</h1>

<h2>1. はじめに</h2>
<p>
前提知識は<span class="highlight">SQL実行</span>、<span class="highlight">トランザクション</span>、<span class="highlight">結合</span>、<span class="highlight">バックアップ/リストア</span>の基礎です。
</p>
<p>
本資料では<span class="highlight-strong">PITRの構成要素</span>、演習環境での<span class="highlight-strong">PITR再現手順</span>、失敗時の切り分けに焦点を置きます。
</p>

<h2>2. 演習環境の前提</h2>
<ul>
  <li>PostgreSQL 17 / Docker</li>
  <li>授業提供の演習用コンテナ環境</li>
  <li>PowerShell / bash どちらでも可</li>
</ul>
<p>
本講義資料のリンク：<a href="https://takeshiwada1980.github.io/DB-2025/">DB-2025 講義資料 Index</a>
</p>
<p>
第12回講義のバックアップ/リストアの内容を復習してから進むとスムーズ：
<a href="https://takeshiwada1980.github.io/DB-2025/lecture12.html#%E3%83%90%E3%83%83%E3%82%A2%E3%83%83%E3%83%97%E3%81%A8%E3%83%AA%E3%82%B9%E3%83%88%E3%82%A2">第12回講義: バックアップとリストア</a>

<h3>2.2 学習タイムライン</h3>
<ul>
  <li>2. バックアップ復習：論理バックアップの限界を確認</li>
  <li>3. PITRの仕組み：タイムライン分岐の理解を追加</li>
  <li>4. ハンズオン準備：アーカイブ設定と再起動確認</li>
  <li>4.5〜4.6 リカバリ演習：ログの読み方を含む</li>
  <li>5. トラブルシューティング：失敗体験を組み込む</li>
  <li>6-7. 定着確認・ドリル</li>
</ul>
</p>

<h3>2.1 バックアップ/リストアの復習</h3>
<p>
PITRの前に、基本のバックアップ/リストアを整理します。ここでは<strong>論理バックアップ</strong>を中心に扱い、SQLとして取り出す方式を確認します。
</p>
<ul>
  <li><span class="highlight">目的</span>：壊したときに「安全に戻せる」状態を作る</li>
  <li><span class="highlight">粒度</span>：DB全体 / スキーマ / テーブル単位で取得できる</li>
  <li><span class="highlight">基本思想</span>：バックアップは「取りっぱなし」ではなく、リストアできることが重要</li>
</ul>

<h4>用語の意味</h4>
<p>
<span class="highlight">バックアップ</span>はデータを安全な場所に複製して保存すること。
<span class="highlight">リストア</span>はバックアップからデータを戻し、元の状態に復元すること。
</p>

<h4>バックアップの種類</h4>
<p>
バックアップには大きく<strong>論理バックアップ</strong>と<strong>物理バックアップ</strong>がある。
PITRは物理バックアップであるベースバックアップとWALの組み合わせが前提になるため、
論理だけでなく物理の特徴も把握しておく必要がある。
</p>
<ul>
  <li><span class="highlight">論理バックアップ</span>：SQLとして取り出す。pg_dump を使う。<strong>可搬性が高い</strong>が、復元に時間がかかる。</li>
  <li><span class="highlight">物理バックアップ</span>：DBファイルを丸ごと複製します。pg_basebackup を使います。<strong>復旧が速い</strong>ですが、同一バージョン前提です。</li>
</ul>

<h4>論理バックアップの形式と使い分け</h4>
<p>
pg_dump の出力形式は用途で選ぶ。SQL形式は人が読めるがサイズが大きくなりやすい。
カスタム形式は圧縮・並列復元に向いている。
</p>
<pre><code class="language-bash">
# 例: SQL形式
pg_dump -d mydb -f backup.sql

# 例: カスタム形式
pg_dump -d mydb -F c -f backup.dump
</code></pre>
<ul>
  <li>SQL形式：小規模DBや学習用途に向く</li>
  <li>カスタム形式：本番運用での標準的な選択肢</li>
</ul>

<details>
  <summary>演習：論理バックアップと物理バックアップをどう使い分けますか？</summary>
  <p>
    「テーブル単位で戻したいケース」と「障害直後に全体を早く戻したいケース」をそれぞれ想定し、
    どちらの方式を選ぶか理由つきで説明してみてください。
  </p>
</details>

<h4>論理バックアップの細かい粒度</h4>
<p>
pg_dumpはDB全体だけでなく、スキーマやテーブル単位で切り出せる。
障害対応で「一部だけ戻したい」状況に強い。
</p>
<pre><code class="language-bash">
# スキーマ単位
pg_dump -d mydb -n public -f public.sql

# テーブル単位
pg_dump -d mydb -t orders -f orders.sql
</code></pre>

<h4>リストアの基本パターン</h4>
<p>
復元では接続先と形式の指定が重要。SQLはpsqlで流し込み、カスタム形式はpg_restoreを使う。
<p>
復元では接続先と形式の指定が重要。SQLはpsqlで流し込み、カスタム形式はpg_restoreを使う。
</p>

# カスタム形式の復元。必要なテーブルだけ指定も可
pg_restore -d mydb -t orders backup.dump
</code></pre>

<h4>復元前の準備チェック</h4>
<ul>
  <li><span class="highlight">接続先の明示</span>：ホスト/ポート/DB名を明確にして誤爆を防ぐ</li>
  <li><span class="highlight">権限の整備</span>：オーナー/ロールの差分で失敗しやすい</li>
  <li><span class="highlight">空のDBを用意</span>：上書き事故を避けるため新規DBへ戻す</li>
</ul>

<h4>復元後の検証</h4>
<p>
復元後は件数・主要テーブル・インデックスの有無を確認し、早期に異常を検知してください。
</p>
<pre><code class="language-sql">
-- 件数確認
SELECT COUNT(*) FROM orders;

-- 主要テーブルの存在確認
\dt
</code></pre>

<h4>バックアップの保存戦略</h4>
<p>
バックアップは1世代だけだと「壊れたバックアップ」しか残らない可能性がある。世代管理と保管先分離でリスクを下げる。
</p>
<ul>
  <li>複数世代を保持。日次×7、週次×4 など</li>
  <li>本番と同一ディスクには置かない</li>
  <li>バックアップの暗号化・アクセス制御を徹底</li>
</ul>

<h4>自動化の第一歩</h4>
<p>
手動運用の抜けを防ぐため、定期実行とログ保存の導入を推奨します。
</p>
<pre><code class="language-bash">
# 例: ダンプの実行ログを残す
pg_dump -d mydb -F c -f /backup/dumps/mydb_20260129.dump \
  &gt; /backup/logs/backup_20260129.log 2&gt;&amp;1
</code></pre>

<h4>よくある疑問：論理バックアップだけで十分？</h4>
<p>
論理バックアップは時点指定の復旧には対応できない。PITRには<strong>物理バックアップ + WAL</strong>が必須。
</p>

<h4>論理バックアップの代表例</h4>
<p>
よく使うのは <span class="highlight">pg_dump</span> と <span class="highlight">pg_restore</span> です。SQLまたはカスタム形式で保存し、必要に応じて復元します。
</p>
<pre><code class="language-bash">
# 例: 単一DBをダンプ
pg_dump -d mydb -f backup.sql

# 例: SQLを流し込んで復元
psql -d mydb -f backup.sql
</code></pre>

<h4>復元の時に起きやすいポイント</h4>
<ul>
  <li>接続先が間違っていないか。誤って本番へ流さない</li>
  <li>権限やオーナーの違いで失敗することがある</li>
  <li>復元後の整合性チェックは必須。件数、主要テーブルの確認</li>
</ul>

<div class="column">
  <div class="column-title">復習の要点</div>
  <p class="column-note">
  バックアップは取得よりも<strong>復元が成功するか</strong>が重要。
  PITRは復元を時点指定で行う技術と位置付ける。
  </p>
</div>

<h4>よくない例</h4>
<ul>
  <li>バックアップを取るだけで、<span class="highlight">復元テストをしていない</span></li>
  <li>取得先が同じディスクで、障害時に<span class="highlight">同時に失われる</span></li>
  <li>本番データをそのまま持ち出し、<span class="highlight">マスキングや権限分離をしない</span></li>
  <li>運用ルールが曖昧で、<span class="highlight">誰がいつ復元するか不明</span></li>
</ul>

<h4>こういうケースもある</h4>
<ul>
  <li>巨大DBでは、まず<span class="highlight">スキーマだけ復元</span>して動作確認する</li>
  <li>アプリの都合で、<span class="highlight">特定テーブルだけ先に戻す</span>必要がある</li>
  <li>監査対応で、<span class="highlight">復元ログの保存</span>が必須になる</li>
  <li>復元先は本番ではなく、<span class="highlight">検証環境で手順を固めてから</span>本番に適用</li>
</ul>

<h4>運用の現実</h4>
<ul>
  <li>復元時間が長いなら、<span class="highlight">バックアップ世代の間隔</span>を見直す</li>
  <li>失敗原因は大抵「<span class="highlight">権限・接続先・ファイルパス</span>」のどれか</li>
  <li>手順は短く書くより、<span class="highlight">やること・やらないこと</span>を明示する</li>
</ul>

<h2>3. PITRの全体像</h2>
<p>
PITRは「<span class="highlight-strong">ベースバックアップ</span> + <span class="highlight-strong">WALアーカイブ</span> + <span class="highlight-strong">復旧設定</span>」の組み合わせで成立します。ベースバックアップはある時点の完全コピー、WALはそれ以降の更新履歴です。復旧時には戻す時点を指定します。
</p>
<ul>
  <li>ベースバックアップ：DB全体のスナップショット</li>
  <li>WALアーカイブ：更新履歴。Write-Ahead Logging</li>
  <li>復旧設定：restore_command と recovery_target_time</li>
</ul>

<h3>3.1 PITRを使う利点</h3>
<p>
PITRの利点は<span class="highlight-strong">特定時点への復旧</span>ができることです。誤ってテーブルを削除した場合でも、削除直前の時点に復旧できます。
</p>
<p>
PITRはベースバックアップがなければ成立しません。基本のバックアップは必須です。
</p>
<ul>
  <li>誤操作の直前に戻せる。DROP/UPDATE/DELETE など</li>
  <li>障害発生時の復旧範囲を最小化できる</li>
  <li>「バックアップはあるが直近データが必要」の状況に強い</li>
</ul>
<div class="column">
  <div class="column-title">コラム：トランザクション処理だけでは不十分か</div>
  <p class="column-note">
  トランザクションは「その処理の中で失敗した場合に元に戻す」仕組み。誤操作が<strong>コミット済み</strong>だったり、
  既にアプリが落ちてしまった後だと、トランザクションでは戻せない。PITRは「処理が終わってしまった後」にも
  時点指定で巻き戻せるのが決定的な違い。
  </p>
</div>

<h3>3.2 WALの仕組み</h3>
<p>
WALは<span class="highlight">先にログを書いてから実データを更新する</span>仕組みです。障害発生時でもログを再生すれば同じ状態を再現できます。PITRはこのWALを時系列で適用し、指定時刻で停止します。
</p>
<p>
WALが残っていても<span class="highlight">WALだけでは復旧できない</span>点に注意してください。
</p>
<ul>
  <li>WALは更新の順番を保証する</li>
  <li>アーカイブは「WALを退避して保管する」こと</li>
  <li>WALが欠落すると、その区間は復旧できない</li>
</ul>
<div class="column">
  <div class="column-title">補足：WALは「戻す」ためのログか</div>
  <p class="column-note">
  WALは基本的に「前に進めるためのログ、REDO」として使われます。PITRはWALを順に再生し、
  指定時刻で止めることで結果的に「戻したように見せる」仕組みです。
  </p>
</div>
<div class="column">
  <div class="column-title">参考質問例</div>
  <p class="column-note">
  「WAL が REDO ログである理由を、障害復旧の観点で具体例つきで説明してください。」
  </p>
</div>

<details>
  <summary>演習：WALだけで復旧できない理由を説明してください</summary>
  <p>
    「完全コピーがない状態」と「完全コピーがある状態」で、復旧できる範囲がどう違うかを比較して説明してください。
  </p>
</details>

<h3>3.3 ベースバックアップの役割</h3>
<p>
WALだけでは復旧できない。<span class="highlight-strong">起点となるスナップショット</span>が必要であり、WALは差分のため完全コピーがなければ復元できない。
</p>
<p>
ベースバックアップが古いと復旧が長引くため、<span class="highlight">取得間隔の見直し</span>が重要。
</p>

<h3>3.4 復旧ターゲットの種類</h3>
<p>
PITRは時刻以外にも停止位置を指定できる。
</p>
<ul>
  <li>recovery_target_time：時刻指定。直感的</li>
  <li>recovery_target_lsn：LSN指定。より厳密</li>
  <li>recovery_target_name：リカバリーポイント名指定</li>
</ul>
<div class="column">
  <div class="column-title">補足：LSNの定義</div>
  <p class="column-note">
  LSNはLog Sequence Numberの略で、WALの位置を表す番号。時刻よりも厳密に位置を指定できるため、
  監査や再現性が重視されるケースで有効。
  </p>
</div>

<h3>3.4.1 タイムラインの考え方</h3>
<p>
PITRで復旧を行うと、<span class="highlight">履歴が分岐</span>してタイムラインが変わる。
タイムライン1から復旧すると、新しいタイムライン2が始まる。
</p>
<pre><code class="language-text">
Timeline 1: ----A----B----C----(誤操作)
                         \
Timeline 2:               ----D----E----(復旧後の新しい履歴)
</code></pre>
<p>
復旧設定に <span class="highlight">recovery_target_timeline = 'latest'</span> を明示して最新タイムラインを追従させる。
</p>

<div class="column">
  <div class="column-title">補足：recovery_target_action の役割</div>
  <p class="column-note">
  recovery_target_action は「目標時刻に到達した後の動作」を決める。
  デフォルトは <span class="highlight">pause</span> で、読み取りはできても書き込みができない状態になる。
  書き込みを再開したい場合は <span class="highlight">promote</span> を指定するか、
  復旧後に <span class="highlight">SELECT pg_wal_replay_resume();</span> を実行して通常稼働へ移行します。
  </p>
</div>
<div class="column">
  <div class="column-title">参考質問例</div>
  <p class="column-note">
  「PostgreSQL の LSN とは何か。PITR で使う理由を短く説明してください。」
  </p>
</div>

<h3>3.5 「ダンプ復元」との違い</h3>
<p>
pg_dump + psql の復元は「その時点の状態に戻す」だけで、時点指定ができない。
PITRは「誤操作直前」など細かい時点に戻せる点が大きな違い。
</p>

<h3>3.6 運用での考え方</h3>
<p>
PITRは運用設計とセットで扱う。<span class="highlight-strong">RPO</span>は失ってよい最大時間、<span class="highlight-strong">RTO</span>は復旧に許される時間。これらを意識すると、
どの頻度でバックアップし、どれだけWALを保存すべきか判断できる。
</p>
<ul>
  <li>RPOが短いほどWAL欠落が許されない</li>
  <li>RTOが短いほど復旧手順の自動化が必要</li>
</ul>
<h3>3.7 事例で見るPITR</h3>
<p>
午前中の運用作業で、担当者が間違えて重要テーブルを削除してしまったとします。監視にはエラーが上がり、
ユーザから「データが消えた」と連絡が入った。ここで求められるのは、<span class="highlight">直前の時点に戻す</span>こと。
PITRはこの状況で最短復旧を実現するための選択肢になる。
</p>
<ol>
  <li>「いつ消えたか」を時刻で確定する</li>
  <li>ベースバックアップとWALアーカイブを確認</li>
  <li>復旧ターゲットを設定して再起動</li>
  <li>テーブルの整合性を検証し、業務を再開</li>
</ol>
<div class="column">
  <div class="column-title">現場メモ：時刻の確定が最重要</div>
  <p class="column-note">
  「消えた瞬間の時刻」が曖昧だと、復旧の止めどころが分からない。監査ログやアプリログと照らし合わせ、
  1分単位で時刻を確定します。
  </p>
</div>

<h3>3.8 失敗しやすいパターンと回避策</h3>
<ul>
  <li>WALアーカイブの保存先が満杯 → <span class="highlight">容量監視</span>とローテーションを設計する</li>
  <li>ベースバックアップの世代が古すぎる → <span class="highlight">定期取得</span>を必須化する</li>
  <li>復旧ターゲット時刻が未来 → <span class="highlight">ログ時刻と整合</span>をとる</li>
  <li>復旧後に書き込みできない → <span class="highlight">recovery_target_action</span> と <span class="highlight">pg_wal_replay_resume()</span> を確認する</li>
</ul>

<h3>3.9 時系列で見るPITR</h3>
<p>
「ベース → WAL適用 → ターゲット停止」という流れを時系列で整理します。
</p>
<ol>
  <li>ベースバックアップ取得。時刻A</li>
  <li>WALアーカイブが蓄積。A〜B</li>
  <li>障害発生。時刻B</li>
  <li>復旧ターゲットは時刻B直前で停止</li>
</ol>
<div class="column">
  <div class="column-title">参考質問例</div>
  <p class="column-note">
  「PITRの流れを『時系列の出来事』として説明してください。1分で読める長さで。」
  </p>
</div>
<h3>3.10 時刻特定の手法・自動ログと手動記録</h3>
<p>
PITRで最も難しいのは「何時何分何秒に戻すべきか」を特定することです。これには主に2つの自動ログが活用されます。
</p>
<div class="column">
  <div class="column-title">1. データベースによる実行ログ（postgresql.log）</div>
  <p class="column-note">
    PostgreSQLの設定で <code>log_statement = 'all'</code> が有効な場合、実行されたすべてのSQLとその時刻がログファイルに自動記録されます。実務ではこのログから「誤操作が行われた正確な時刻」を特定します。
  </p>
</div>
<div class="column">
  <div class="column-title">2. テーブル設計による自動タイムスタンプ</div>
  <p class="column-note">
    今回の演習で使用する <code>x_gold_transfers</code> には、データ挿入時に自動で時刻を記録する <code>transferred_at</code> カラムが定義されています。このように、データそのものに「いつ作られたか」が自動で刻まれる設計にしておくことも、復旧時の重要な手がかりとなります。
  </p>
</div>
<h2>4. ハンズオン学習</h2>
<h3>4.1 作業用ディレクトリの準備</h3>
<p>バックアップ先とアーカイブ先を明示的に作成します。</p>
<p>
このハンズオンは、講義資料どおりに構築済みの <span class="highlight">DB-PostgreSQL</span> フォルダを前提とします。
VSCodeでDB-PostgreSQLを開き、ターミナルはそのフォルダを作業ディレクトリにしてください。
</p>
<p>
まずはターミナルの作業場所とコンテナの起動状況を確認します。ここがズレると以降の作業がすべてズレるため、
最初に丁寧に確認しておきます。
</p>
<pre><code class="language-bash">
# VSCodeでプロジェクトを開いた状態で実行。PowerShell想定
pwd
</code></pre>
<p>出力が <span class="highlight">DB-PostgreSQL</span> 配下であることを確認してください。</p>
<div class="column">
  <div class="column-title">補足：演習環境の起動確認</div>
  <p class="column-note">
  まだコンテナが起動していない場合は、講義資料の手順に従って起動してください。
  </p>
</div>
<pre><code class="language-bash">
# Dockerコンテナ起動。講義資料の手順に従う
npm run db:up
</code></pre>
<pre><code class="language-bash">
# 起動確認
docker ps
</code></pre>
<pre><code class="language-bash">
mkdir -p /backup/base
mkdir -p /backup/wal_archive
</code></pre>

<h3>4.2 WALアーカイブ設定の確認</h3>
<p>
まずは現在の設定を確認します。設定ファイルを直接編集する場合は、操作権限と再起動が必要になるため注意してください。
</p>
<div class="column">
  <div class="column-title">Docker環境の設定ファイル編集 重要</div>
  <p class="column-note">
  Docker環境ではコンテナ内の <span class="highlight">/var/lib/postgresql/data/postgresql.conf</span> が本体設定。
  ただし、PITRの一時的な設定は <span class="highlight">postgresql.auto.conf</span> に追記する方が安全。
  例：設定追記 → 再起動、の順に行う。
  </p>
</div>
<pre><code class="language-bash">
# 例: postgresql.auto.conf へ追記。コンテナ内で実行
docker exec -it db-postgres bash -c "echo \"recovery_target_time = '2026-01-27 10:30:00'\" &gt;&gt; /var/lib/postgresql/data/postgresql.auto.conf"
docker exec -it db-postgres bash -c "echo \"recovery_target_timeline = 'latest'\" &gt;&gt; /var/lib/postgresql/data/postgresql.auto.conf"
docker exec -it db-postgres bash -c "echo \"recovery_target_action = 'promote'\" &gt;&gt; /var/lib/postgresql/data/postgresql.auto.conf"
docker exec -it db-postgres bash -c "echo \"restore_command = 'cp /backup/wal_archive/%f %p'\" &gt;&gt; /var/lib/postgresql/data/postgresql.auto.conf"

# 例: 再起動で反映
docker restart db-postgres
</code></pre>
<p>
設定を変える前に、<span class="highlight">今の値を控える</span>ことは必須です。戻せなくなると原因調査が難しくなります。
</p>
<p>
SQLの実行は、講義資料どおりに <span class="highlight">VSCodeのタスク実行</span> または
<span class="highlight">ターミナルからnpm run sql</span> を使う。以下はターミナル実行の例。
</p>
<pre><code class="language-bash">
# 例: 一時ファイルを作ってSQLを実行
code sql/tmp_pitr.sql
npm run sql sql/tmp_pitr.sql
</code></pre>
<pre><code class="language-sql">
SHOW archive_mode;
SHOW archive_command;
SHOW wal_level;
</code></pre>

<p>postgresql.conf の代表的な設定例です。環境に合わせて調整してください。</p>
<pre><code class="language-ini">
archive_mode = on
archive_command = 'test ! -f /backup/wal_archive/%f &amp;&amp; cp %p /backup/wal_archive/%f'
wal_level = replica
</code></pre>
<div class="column">
  <div class="column-title">補足：archive_command が失敗する代表例</div>
  <p class="column-note">
  パスの存在・権限不足・同名ファイルの衝突が多い。`test ! -f` で上書きを防ぎつつ、
  実際にアーカイブ先にファイルが作成されているか確認すること。
  </p>
</div>

<details>
  <summary>演習：archive_command の失敗をどう切り分けますか？</summary>
  <p>
    パス、権限、既存ファイル衝突、ログ出力の4点を順に確認して、
    どこで失敗しているかを1つずつ切り分けてください。
  </p>
</details>
<div class="column">
  <div class="column-title">参考質問例</div>
  <p class="column-note">
  「archive_command が失敗する典型例と、確認すべきログの場所を教えてください。」
  </p>
</div>

<h3>4.3 ベースバックアップの取得</h3>
<p>ベースバックアップは復旧の起点になる。まずは取得しておく。</p>
<pre><code class="language-bash">
pg_basebackup -D /backup/base -Fp -Xs -P
</code></pre>
<p>
<strong>-D</strong> は出力先、<strong>-Fp</strong> はプレーン形式、<strong>-Xs</strong> はWALのストリーミング取得、<strong>-P</strong> は進捗表示。
</p>

<h3>4.4 WAL生成とアーカイブ確認</h3>
<h4>4.4.1 テスト用テーブル作成</h4>
<pre><code class="language-sql">
CREATE TABLE pitr_demo (
  id SERIAL PRIMARY KEY,
  message TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
</code></pre>

<h4>4.4.2 変更を発生させる</h4>
<pre><code class="language-sql">
INSERT INTO pitr_demo (message) VALUES
  ('first'),
  ('second'),
  ('third');
</code></pre>

<h4>4.4.3 WALアーカイブの生成を促す</h4>
<pre><code class="language-sql">
SELECT pg_switch_wal();
</code></pre>

<h4>4.4.4 アーカイブ確認</h4>
<pre><code class="language-bash">
ls -la /backup/wal_archive
</code></pre>

<h3>4.5 障害発生の再現</h3>
<p>削除直前の時刻を記録しておく。復旧ターゲットになる。</p>
<pre><code class="language-sql">
SELECT now();
SELECT * FROM pitr_demo ORDER BY id;
</code></pre>

<p>誤操作として削除を実行。</p>
<pre><code class="language-sql">
DROP TABLE pitr_demo;
</code></pre>

<h3>4.6 PITRによる復旧</h3>
<h4>4.6.1 目標時刻の設定</h4>
<p>削除直前の時刻をメモして、その時刻へ復旧してください。</p>
<pre><code class="language-ini">
recovery_target_time = '2026-01-27 10:30:00'
recovery_target_timeline = 'latest'
recovery_target_action = 'promote'
</code></pre>
<p>
<span class="highlight">recovery_target_action = 'promote'</span> を指定しない場合は pause になるので、
復旧後に書き込みができない状態になる。pauseのままにする場合は、
復旧後に <span class="highlight">SELECT pg_wal_replay_resume();</span> を実行して通常稼働へ移行します。
</p>

<h4>4.6.2 リストア用の基本設定</h4>
<pre><code class="language-ini">
restore_command = 'cp /backup/wal_archive/%f %p'
</code></pre>
<p>
ここでパスを間違えると、<span class="highlight">無言で復旧が進まない</span>ことがある。ログ確認はセット。
</p>

<h4>4.6.3 復旧シグナルの用意</h4>
<pre><code class="language-bash">
touch recovery.signal
</code></pre>
<p>
Docker環境では <span class="highlight">/var/lib/postgresql/data</span> に作成します。例：
<span class="highlight">docker exec -it db-postgres bash -c "touch /var/lib/postgresql/data/recovery.signal"</span>
</p>
<p>
このコマンドは <span class="highlight">コンテナが起動している状態</span>で実行する必要がある。
実行直後に <span class="highlight">docker restart db-postgres</span> を行う流れにすると迷いにくい。
</p>
<div class="column">
  <div class="column-title">順序の確認 重要</div>
  <p class="column-note">
  1) <span class="highlight">設定ファイルを反映</span>。postgresql.auto.conf へ追記 →
  2) <span class="highlight">recovery.signal を作成</span> →
  3) <span class="highlight">サーバー起動</span>。コンテナ start
  この順序が崩れると、設定が反映されないまま起動して復旧が進まないことがある。
  </p>
</div>

<h4>4.6.4 復旧後の確認</h4>
<pre><code class="language-sql">
SELECT * FROM pitr_demo ORDER BY id;
</code></pre>

<h4>4.6.5 復旧状況の監視コマンド</h4>
<pre><code class="language-sql">
-- 復旧中かどうか
SELECT pg_is_in_recovery();

-- 受信済み/再生済みのWAL位置
SELECT pg_last_wal_receive_lsn();
SELECT pg_last_wal_replay_lsn();

-- 最後に再生したトランザクション時刻
SELECT pg_last_xact_replay_timestamp();
</code></pre>

<h2>5. 注意点</h2>
<ul>
  <li>アーカイブ先のパスが存在しない／権限がない</li>
  <li>archive_command が失敗している。ログで確認</li>
  <li>recovery_target_time の形式ミス</li>
  <li>ベースバックアップ取得後にWALが欠落している</li>
  <li>復旧後の起動が終了しない。ターゲット時刻未到達</li>
  <li>復旧後にアプリが動かない。<span class="highlight">接続先が旧DBのまま</span></li>
</ul>

<h3>5.1 失敗体験</h3>
<p>
「意図的な失敗」を組み込み、トラブルシューティングの手順を確認します。
</p>
<ol>
  <li>restore_command のパスをわざと間違える</li>
  <li>起動後に <span class="highlight">復旧が進まない</span>ことを確認</li>
  <li><span class="highlight">docker logs db-postgres</span> でエラーを確認</li>
  <li>正しいパスに戻して復旧を再実行</li>
</ol>

<h3>5.2 WALの掃除</h3>
<p>
WALアーカイブを溜め続けるとディスクが溢れます。古いWALを削除する場合は
<span class="highlight">pg_archivecleanup</span> の利用を検討してください。
</p>
<pre><code class="language-bash">
# 例: 古いWALを削除。最新のWALファイルを基準に
pg_archivecleanup /backup/wal_archive 0000000100000000000000A3
</code></pre>

<details>
  <summary>演習：WAL削除の安全条件を説明してください</summary>
  <p>
    「どのベースバックアップに対して、どの時点まで復旧する可能性があるか」を先に決めると、
    消してよいWALの範囲を説明しやすくなります。
  </p>
</details>

<h2>6. 定着確認</h2>
<p>
以下の空欄補充を使って、PITRの要点を確認してください。
</p>
<ol>
  <li>ベースバックアップは<span class="masked">起点となる完全コピー</span>、WALアーカイブは<span class="masked">更新履歴の保管</span>を表す。</li>
  <li><span class="masked">pg_basebackup</span>はDB全体のスナップショットを取得する。</li>
  <li>archive_command が失敗した場合は<span class="masked">PostgreSQLログ</span>と<span class="masked">アーカイブ先の権限/パス</span>を確認する。</li>
  <li>recovery_target_time は<span class="masked">復旧を止める時点</span>を指定するために使う。</li>
  <li>復旧後に動作不良があれば、まず<span class="masked">WAL欠落の有無</span>を確認する。</li>
  <li>WALは基本的に<span class="masked">REDOログ</span>として機能する。</li>
  <li>PITRはWALを<span class="masked">時系列に適用</span>し、指定時刻で停止する。</li>
  <li>RPOは<span class="masked">失ってよい最大時間</span>、RTOは<span class="masked">復旧に許される時間</span>を指す。</li>
  <li>LSNは<span class="masked">WALの位置</span>を表す番号である。</li>
  <li>ベースバックアップが古すぎると<span class="masked">復旧時間が長くなる</span>。</li>
  <li>WAL保存先が満杯だと<span class="masked">アーカイブが停止</span>する。</li>
  <li>復旧ターゲット時刻は<span class="masked">ログ時刻と整合</span>を取る必要がある。</li>
  <li>復旧後に書き込みできない場合は<span class="masked">recovery.signal</span>を確認する。</li>
  <li>PITRは<span class="masked">時点指定の復旧</span>が最大の強みである。</li>
  <li>監査対応では<span class="masked">LSN指定</span>が有効な場合がある。</li>
</ol>

<details>
  <summary>演習：RPOとRTOを自分の運用に当てはめてください</summary>
  <p>
    1時間以内に復旧したい場合、ベースバックアップ頻度・WAL保持期間・手順自動化をどう設計するか整理してみてください。
  </p>
</details>

<h2>7. SQLドリル / 演習</h2>
<p>
本演習では、第10回講義などで構築した <code>x_characters</code> や <code>x_gold_transfers</code> テーブルを使用します。
単にクエリを書くだけでなく、あえて誤ったコードを確定（COMMIT）させ、その後にPITRを用いて正常な状態へ戻すプロセスを体験します。
</p>

<div class="column">
  <div class="column-title">演習環境の再構築</div>
  <p class="column-note">
    演習の結果、テーブル構造や初期データが不明になった場合は、
    <code>from-teacher/10/create-x_db.sql</code> を実行して環境を初期状態にリセットしてください。
    このスクリプトにより、キャラクター情報やギルド所属情報が正しく再生成されます。
  </p>
</div>

<div class="column">
  <div class="column-title">時刻特定とログの仕組み</div>
  <p class="column-note">
    PITRで最も重要な「復旧時刻」の特定には、主に2つの方法があります。
    一つはデータベースの実行ログ（postgresql.log）を確認する方法で、設定により実行されたSQLと時刻が自動記録されます。
    もう一つは、<code>x_gold_transfers</code> の <code>transferred_at</code> カラムのように、データ自体に自動付与されるタイムスタンプを参照する方法です。
    本演習では <code>SELECT now();</code> を用いて手動で時刻をメモしますが、実務ではこれらの自動ログが頼りになります。
  </p>
</div>

<h3>ex-03_1：条件指定漏れによる全キャラクターの所持金更新</h3>
<p>
特定のキャラクターのゴールドを調整するつもりが、WHERE句を書き忘れたために、全キャラクターのゴールドを0に更新して確定させてしまったケースを再現します。
</p>
<div class="column">
  <div class="column-title">ステップ1：誤操作の実行</div>
  <p class="column-note">まず現在時刻をメモし、以下のコードを実行・確定してください。</p>
<pre><code class="language-sql">
-- 現在時刻をメモ
SELECT now();

BEGIN;
UPDATE x_characters SET gold = 0; 
COMMIT;
</code></pre>
</div>
<div class="column">
  <div class="column-title">ステップ2：リカバリ課題</div>
  <p class="column-note">
    メモした時刻をターゲットにPITRを行い、キャラクターのゴールドが初期値（例：Marvinは50,000G）に戻っているか確認してください。
  </p>
</div>

<hr>

<h3>ex-03_2：報酬配布スクリプトの二重実行</h3>
<p>
配布スクリプトを誤って2回連続で実行したために、送金履歴テーブルに重複したレコードが記録されてしまったケースを再現します。
</p>
<div class="column">
  <div class="column-title">ステップ1：重複データの発生</div>
  <p class="column-note">以下の配布処理を<strong>2回</strong>実行し、COMMITしてください。1回目と2回目の間の時刻を特定する必要があります。</p>
<pre><code class="language-sql">
BEGIN;
INSERT INTO x_gold_transfers (from_character_id, to_character_id, amount, transferred_at)
SELECT '_SYS_', id, 10000, now() FROM x_characters WHERE deleted_at IS NULL;
COMMIT;
</code></pre>
</div>
<div class="column">
  <div class="column-title">ステップ2：リカバリ課題</div>
  <p class="column-note">
    1回目の実行は正当な配布とし、2回目の実行が行われる直前の時刻まで巻き戻して、重複を解消してください。
  </p>
</div>

<hr>

<h3>ex-03_3：物理削除事故</h3>
<p>
本来は論理削除（deleted_atの更新）をすべきところを、誤って物理削除（DELETE）を実行し、ギルド所属情報を消去してしまったケースを再現します。
</p>
<div class="column">
  <div class="column-title">ステップ1：物理削除の実行</div>
<pre><code class="language-sql">
-- 実行前の時刻をメモ
SELECT now();

BEGIN;
DELETE FROM x_guild_characters WHERE character_id = 'C001'; 
COMMIT;
</code></pre>
</div>
<div class="column">
  <div class="column-title">ステップ2：リカバリ課題</div>
  <p class="column-note">
    物理削除されたレコードはROLLBACKでは戻せません。PITRを行い、対象の所属レコードを復活させてください。
  </p>
</div>

<hr>

<h3>ex-03_4：本番テーブルの誤削除</h3>
<p>
作業用テーブルを削除するつもりが、誤って <code>x_guilds</code> テーブルそのものを削除してしまったケースを想定します。
</p>
<div class="column">
  <div class="column-title">リカバリ課題</div>
  <p class="column-note">
    <code>DROP TABLE x_guilds;</code> を実行した後、PITRによってテーブル構造とデータの両方を復旧させてください。
  </p>
</div>

<hr>

<h3>ex-03_5：一斉昇級処理のロジックエラー</h3>
<p>
全キャラクターのゴールドを1.1倍（10%増）にするつもりが、誤って <code>gold * 10</code> （10倍）にして確定してしまったケースを再現します。
</p>
<div class="column">
  <div class="column-title">ステップ1：誤った一斉更新</div>
<pre><code class="language-sql">
BEGIN;
UPDATE x_characters SET gold = gold * 10;
COMMIT;
</code></pre>
</div>
<div class="column">
  <div class="column-title">ステップ2：リカバリ課題</div>
  <p class="column-note">
    経済バランスが壊れた状態から、実行数秒前の時刻を指定して元のゴールド量へ巻き戻してください。
  </p>
</div>

<hr>

<h3>ex-03_6：ギルド解散処理の誤適用</h3>
<p>
特定のギルドのメンバーを脱退させるつもりが、条件指定のミスで全ギルドの所属情報を削除してしまったケースを想定します。
</p>
<div class="column">
  <div class="column-title">リカバリ課題</div>
  <p class="column-note">
    <code>DELETE FROM x_guild_characters;</code> を実行・確定した後、削除直前の時刻を特定し、全メンバーの所属状況を復元してください。
  </p>
</div>

<h2>8. 演習の解答例</h2>
<p>各演習に共通する標準的なリカバリ手順の考え方です。時刻やパスは各自の環境に合わせて調整してください。</p>

<details>
<summary>共通リカバリ・テンプレート</summary>
<div class="column">
  <div class="column-title">リカバリ用パラメータ設定</div>
  <p class="column-note">
    postgresql.auto.conf への反映例です。時刻やパスは各自の環境に合わせて書き換えてください。
  </p>
  <pre><code class="language-bash">
# パラメータの記述例
docker exec -it db-postgres bash -c "echo \"restore_command = 'cp /backup/wal_archive/%f %p'\" >> /var/lib/postgresql/data/postgresql.auto.conf"
docker exec -it db-postgres bash -c "echo \"recovery_target_time = '2026-02-16 10:00:00'\" >> /var/lib/postgresql/data/postgresql.auto.conf"
docker exec -it db-postgres bash -c "echo \"recovery_target_timeline = 'latest'\" >> /var/lib/postgresql/data/postgresql.auto.conf"
docker exec -it db-postgres bash -c "echo \"recovery_target_action = 'promote'\" >> /var/lib/postgresql/data/postgresql.auto.conf"
  </code></pre>
</div>

<div class="column">
  <div class="column-title">復旧後の確認と再開用SQL</div>
  <p class="column-note">
    リカバリ完了後、データベースの状態を確認し、必要に応じて通常稼働へ移行させます。
  </p>
  <pre><code class="language-sql">
-- リカバリ状態の確認（'t' であればリカバリモード中）
SELECT pg_is_in_recovery();

-- 最後に再生されたトランザクション時刻の確認
SELECT pg_last_xact_replay_timestamp();

-- 通常稼働へ移行（書き込みを許可する）
SELECT pg_wal_replay_resume();
  </code></pre>
</div>
</details>

<hr>

<h3>まとめと復習</h3>
<p>
今回の講義の要点を復習しましょう。黄色い部分をクリックすると正解が表示されます。
</p>
<ul>
  <li>PITRを実現するには、ベースバックアップと <span class="masked">WALアーカイブ</span> の両方が必須です。</li>
  <li>リカバリを開始するには、データディレクトリ内に <span class="masked">recovery.signal</span> という空ファイルを作成します。</li>
  <li>復旧を止めたい特定の時刻は <span class="masked">recovery_target_time</span> パラメータで指定します。</li>
  <li>リカバリ終了直後、DBは「一時停止」状態になるため、<span class="masked">pg_wal_replay_resume()</span> を実行して通常稼働へ移行させる必要があります。</li>
  <li>物理的な破壊（DROP TABLEなど）は、通常の <span class="masked">ROLLBACK</span> では救済できないため、PITRが有効です。</li>
</ul>

<details>
  <summary>最終演習：PITR手順を3分で説明してください</summary>
  <p>
    「起点（ベースバックアップ）」「履歴（WAL）」「停止条件（recovery_target）」の3要素を順番に説明すると、
    実務でも共有しやすい説明になります。
  </p>
</details>


<p class="footer-text"><span class="highlight">制作時間：18時間</span></p>
<footer class="footer">
  <a class="footer-link" href="https://github.com/Tsubasa213" target="_blank" rel="noopener noreferrer">GitHub</a>
  <p class="footer-text">© copyright 2026 Tsubasa213/つばさ all right resolved.</p>
</footer>

</body>
<script src="main.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
<iframe
  src="https://docsbot.ai/iframe/4dWqauk5JhWuOOyVaU35/LcmBqB48fmMf6m6LgGL1"
  frameborder="0"
  scrolling="no"
  class="docsbot-frame">
</iframe>
</html>


<!-- https://qiita.com/yaju/items/51e7b1037a99856e547c　めも -->