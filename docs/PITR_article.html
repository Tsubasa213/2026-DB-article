<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github-dark.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
  <link rel="stylesheet" href="style.css">
  <title>Point In Time Recoveryの実践</title>
</head>
<body class="markdown-body">

<header class="header">
  <h2 class="site-title">DB技術記事</h2>
  <button class="menu-btn" id="menuBtn">☰</button>
</header>

<h1>PostgreSQLにおけるPoint In Time Recoveryの実践</h1>

<h2>1. はじめに</h2>
<p>
前提知識は<span class="highlight">SQL実行</span>、<span class="highlight">トランザクション</span>、<span class="highlight">結合</span>、<span class="highlight">バックアップ/リストア</span>の基礎です。
</p>
<p>
本資料では<span class="highlight-strong">PITRの構成要素</span>、演習環境での<span class="highlight-strong">PITR再現手順</span>、失敗時の切り分けに焦点を置きます。
</p>

<h2>2. 実験環境</h2>
<ul>
  <li>PostgreSQL 17 / Docker</li>
  <li>授業提供の演習用コンテナ環境</li>
  <li>PowerShell / bash どちらでも可</li>
</ul>
<p>
参考リンク：<a href="https://takeshiwada1980.github.io/DB-2025/">DB-2025 講義資料 Index</a>
</p>
<p>
第12回講義のバックアップ/リストアの内容を復習してから進むとスムーズ：
<a href="https://takeshiwada1980.github.io/DB-2025/lecture12.html#%E3%83%90%E3%83%83%E3%82%A2%E3%83%83%E3%83%97%E3%81%A8%E3%83%AA%E3%82%B9%E3%83%88%E3%82%A2">第12回講義: バックアップとリストア</a>
</p>

<h3>2.1 バックアップ/リストアの復習</h3>
<p>
PITRの前に、基本のバックアップ/リストアを整理します。ここでは<strong>論理バックアップ</strong>を中心に扱い、SQLとして取り出す方式を確認します。
</p>
<ul>
  <li><span class="highlight">目的</span>：障害時に安全に戻せる状態を確保します。</li>
  <li><span class="highlight">粒度</span>：DB全体 / スキーマ / テーブル単位で取得可能です。</li>
  <li><span class="highlight">基本思想</span>：取得だけで終えず、リストア成功まで確認します。</li>
</ul>

<h4>用語の意味</h4>
<p>
<span class="highlight">バックアップ</span>はデータを安全な場所に複製して保存すること。
<span class="highlight">リストア</span>はバックアップからデータを戻し、元の状態に復元すること。
</p>

<h4>バックアップの種類</h4>
<p>
バックアップには大きく<strong>論理バックアップ</strong>と<strong>物理バックアップ</strong>があります。
PITRはベースバックアップとWAL（Write-Ahead Logging）の組み合わせが前提です。
そのため、論理だけでなく物理バックアップの特徴も把握しておく必要があります。
</p>
<ul>
  <li><span class="highlight">論理バックアップ</span>：SQLとして取り出す。<code>pg_dump</code> を使う。<strong>可搬性が高い</strong>が、復元に時間がかかる。</li>
  <li><span class="highlight">物理バックアップ</span>：DBファイルを丸ごと複製します。<code>pg_basebackup</code> を使います。<strong>復旧が速い</strong>ですが、同一バージョン前提です。</li>
</ul>

<h4>論理バックアップの形式と使い分け</h4>
<p>
<code>pg_dump</code> の出力形式は用途で選びます。SQL形式は人が読めますが、サイズが大きくなりやすいです。
カスタム形式は圧縮・並列復元に向いています。
</p>
<pre><code class="language-bash">
# 例: SQL形式
pg_dump -d mydb -f backup.sql

# 例: カスタム形式
pg_dump -d mydb -F c -f backup.dump
</code></pre>
<ul>
  <li>SQL形式：小規模DBや学習用途に向く</li>
  <li>カスタム形式：本番運用での標準的な選択肢</li>
</ul>

<details>
  <summary>演習：論理バックアップと物理バックアップをどう使い分けますか？</summary>
  <p>
    「テーブル単位で戻したいケース」と「障害直後に全体を早く戻したいケース」をそれぞれ想定し、
    どちらの方式を選ぶか理由つきで説明してみてください。
  </p>
</details>

<h4>論理バックアップの細かい粒度</h4>
<p>
<code>pg_dump</code> はDB全体だけでなく、スキーマやテーブル単位で切り出せます。
障害対応で「一部だけ戻したい」状況に強みがあります。
</p>
<pre><code class="language-bash">
# スキーマ単位
pg_dump -d mydb -n public -f public.sql

# テーブル単位
pg_dump -d mydb -t orders -f orders.sql
</code></pre>

<h4>リストアの基本パターン</h4>
<p>
復元では接続先と形式の指定が重要です。SQLは <code>psql</code> で流し込み、カスタム形式は <code>pg_restore</code> を使います。
</p>
<pre><code class="language-bash">
# SQL形式の復元
psql -d mydb -f backup.sql

# カスタム形式の復元（必要なテーブルだけ指定も可）
pg_restore -d mydb -t orders backup.dump
</code></pre>

<h4>復元前の準備チェック</h4>
<ul>
  <li><span class="highlight">接続先の明示</span>：ホスト/ポート/DB名を明確にして誤爆を防ぐ</li>
  <li><span class="highlight">権限の整備</span>：オーナー/ロールの差分で失敗しやすい</li>
  <li><span class="highlight">空のDBを用意</span>：上書き事故を避けるため新規DBへ戻す</li>
</ul>

<h4>復元後の検証</h4>
<p>
復元後は件数・主要テーブル・インデックスの有無を確認し、早期に異常を検知してください。
</p>
<pre><code class="language-sql">
-- 件数確認
SELECT COUNT(*) FROM orders;

-- 主要テーブルの存在確認
\dt
</code></pre>

<h4>バックアップの保存戦略</h4>
<p>
バックアップを1世代だけ保持すると「壊れたバックアップ」しか残らない可能性があります。
世代管理と保管先の分離でリスクを下げてください。
</p>
<ul>
  <li>複数世代を保持。日次×7、週次×4 など</li>
  <li>本番と同一ディスクには置かない</li>
  <li>バックアップの暗号化・アクセス制御を徹底</li>
</ul>

<h4>自動化の第一歩</h4>
<p>
手動運用の抜けを防ぐため、定期実行とログ保存の導入を推奨します。
</p>
<pre><code class="language-bash">
# 例: ダンプの実行ログを残す
pg_dump -d mydb -F c -f /backup/dumps/mydb_20260129.dump \
  &gt; /backup/logs/backup_20260129.log 2&gt;&amp;1
</code></pre>

<div class="column">
  <div class="column-title">よくある疑問：論理バックアップだけで十分か</div>
  <p class="column-note">
    論理バックアップだけでは時点指定の復旧に対応できません。PITRには<strong>物理バックアップ + WAL</strong>が<span class="critical-text">必須</span>です。
  </p>
</div>

<h4>論理バックアップの代表例</h4>
<p>
よく使うのは <code>pg_dump</code> と <code>pg_restore</code> です。SQLまたはカスタム形式で保存し、必要に応じて復元します。
</p>
<pre><code class="language-bash">
# 例: 単一DBをダンプ
pg_dump -d mydb -f backup.sql

# 例: SQLを流し込んで復元
psql -d mydb -f backup.sql
</code></pre>

<h4>復元の時に起きやすいポイント</h4>
<ul>
  <li>接続先が間違っていないか。誤って本番へ流さない</li>
  <li>権限やオーナーの違いで失敗することがある</li>
  <li>復元後の整合性チェックは<span class="critical-text">必須</span>。件数、主要テーブルの確認</li>
</ul>

<p>
ここまででバックアップ/リストアの基礎が揃いました。次の「復習の要点」で、PITR理解に必要な観点を短く確認します。
</p>

<div class="column">
  <div class="column-title">復習の要点</div>
  <p class="column-note">
  バックアップは取得よりも<strong>復元が成功するか</strong>が重要。
  PITRは復元を時点指定で行う技術と位置付ける。
  </p>
</div>

<h4>よくない例</h4>
<ul>
  <li>バックアップを取るだけで、<span class="highlight">復元テストをしていない</span></li>
  <li>取得先が同じディスクで、障害時に<span class="highlight">同時に失われる</span></li>
  <li>本番データをそのまま持ち出し、<span class="highlight">マスキングや権限分離をしない</span></li>
  <li>運用ルールが曖昧で、<span class="highlight">誰がいつ復元するか不明</span></li>
</ul>

<h4>こういうケースもある</h4>
<ul>
  <li>巨大DBでは、まず<span class="highlight">スキーマだけ復元</span>して動作確認する</li>
  <li>アプリの都合で、<span class="highlight">特定テーブルだけ先に戻す</span>必要がある</li>
  <li>監査対応で、<span class="highlight">復元ログの保存</span>が必須になる</li>
  <li>復元先は本番ではなく、<span class="highlight">検証環境で手順を固めてから</span>本番に適用</li>
</ul>

<h4>運用の現実</h4>
<ul>
  <li>復元時間が長いなら、<span class="highlight">バックアップ世代の間隔</span>を見直す</li>
  <li>失敗原因は大抵「<span class="highlight">権限・接続先・ファイルパス</span>」のどれか</li>
  <li>手順は短く書くより、<span class="highlight">やること・やらないこと</span>を明示する</li>
</ul>

<h3>定着確認（第2章）</h3>
<ul>
  <li>論理バックアップだけで時点指定復旧は<span class="masked">できない</span>。</li>
  <li>PITRには<span class="masked">物理バックアップ + WAL</span>の組み合わせが必要である。</li>
  <li>復元後は件数確認などの<span class="masked">整合性チェック</span>を必ず行う。</li>
</ul>

<h2>3. PITRの全体像</h2>
<p>
PITRは「<span class="highlight-strong">ベースバックアップ</span> + <span class="highlight-strong">WALアーカイブ</span> + <span class="highlight-strong">復旧設定</span>」の組み合わせで成立します。ベースバックアップはある時点の完全コピー、WALはそれ以降の更新履歴です。復旧時には戻す時点を指定します。
</p>
<ul>
  <li>ベースバックアップ：DB全体のスナップショット</li>
  <li>WALアーカイブ：更新履歴を保管する</li>
  <li>復旧設定：<code>restore_command</code> と <code>recovery_target_time</code></li>
</ul>

<h3>3.1 PITRを使う利点</h3>
<p>
PITRの利点は<span class="highlight-strong">特定時点への復旧</span>ができることです。誤ってテーブルを削除した場合でも、削除直前の時点に復旧できます。
</p>
<p>
PITRはベースバックアップがなければ成立しません。基本のバックアップは必須です。
</p>
<ul>
  <li>誤操作の直前に戻せる。<code>DROP</code>/<code>UPDATE</code>/<code>DELETE</code> など</li>
  <li>障害発生時の復旧範囲を最小化できる</li>
  <li>「バックアップはあるが直近データが必要」の状況に強い</li>
</ul>
<div class="column">
  <div class="column-title">コラム：トランザクション処理だけでは不十分か</div>
  <p class="column-note">
  トランザクションは「その処理の中で失敗した場合に元に戻す」仕組み。誤操作が<strong>コミット済み</strong>だったり、
  既にアプリが落ちてしまった後だと、トランザクションでは戻せない。PITRは「処理が終わってしまった後」にも
  時点指定で巻き戻せるのが決定的な違い。
  </p>
</div>

<h3>3.2 WALの仕組み</h3>
<p>
WALは<span class="highlight">先にログを書いてから実データを更新する</span>仕組みです。障害発生時でもログを再生すれば同じ状態を再現できます。PITRはこのWALを時系列で適用し、指定時刻で停止します。
</p>
<p>
WALが残っていても<span class="highlight">WALだけでは復旧できない</span>点に注意してください。
</p>
<ul>
  <li>WALは更新の順番を保証する</li>
  <li>アーカイブは「WALを退避して保管する」こと</li>
  <li>WALが欠落すると、その区間は復旧できない</li>
</ul>
<div class="column">
  <div class="column-title">補足：WALは「戻す」ためのログか</div>
  <p class="column-note">
  WALは基本的に「前に進めるためのログ、REDO」として使われます。PITRはWALを順に再生し、
  指定時刻で止めることで結果的に「戻したように見せる」仕組みです。
  </p>
</div>
<div class="column">
  <div class="column-title">参考質問例</div>
  <p class="column-note">
  「WALがREDOログとして機能する理由を、障害発生時の復旧手順（ログ再生の流れ）に沿って説明してください。あわせて、UNDOと誤解されやすい点も補足してください。」
  </p>
</div>

<details>
  <summary>演習：WALだけで復旧できない理由を説明してください</summary>
  <p>
    「完全コピーがない状態」と「完全コピーがある状態」で、復旧できる範囲がどう違うかを比較して説明してください。
  </p>
</details>

<h3>3.3 ベースバックアップの役割</h3>
<p>
WALだけでは復旧できません。<span class="highlight-strong">起点となるスナップショット</span>が必要です。
WALは差分情報のため、完全コピーがなければ復元できません。
</p>
<p>
ベースバックアップが古いと復旧が長引くため、<span class="highlight">取得間隔の見直し</span>が重要です。
</p>

<h3>3.4 復旧ターゲットの種類</h3>
<p>
PITRは時刻以外にも停止位置を指定できます。
</p>
<ul>
  <li><code>recovery_target_time</code>：時刻指定。直感的</li>
  <li><code>recovery_target_lsn</code>：LSN指定。より厳密</li>
  <li><code>recovery_target_name</code>：リカバリーポイント名指定</li>
</ul>
<div class="column">
  <div class="column-title">補足：LSNの定義</div>
  <p class="column-note">
  LSNはLog Sequence Numberの略で、WALの位置を表す番号。時刻よりも厳密に位置を指定できるため、
  監査や再現性が重視されるケースで有効。
  </p>
</div>

<h3>3.4.1 タイムラインの考え方</h3>
<p>
PITRで復旧を行うと、<span class="highlight">履歴が分岐</span>してタイムラインが変わる。
タイムライン1から復旧すると、新しいタイムライン2が始まる。
</p>
<pre><code class="language-text">
Timeline 1: ----A----B----C----(誤操作)
                         \
Timeline 2:               ----D----E----(復旧後の新しい履歴)
</code></pre>
<p>
復旧設定に <span class="highlight"><code>recovery_target_timeline = 'latest'</code></span> を明示して最新タイムラインを追従させる。
</p>

<div class="column">
  <div class="column-title">補足：<code>recovery_target_action</code> の役割</div>
  <p class="column-note">
  <code>recovery_target_action</code> は「目標時刻に到達した後の動作」を決める。
  デフォルトは <span class="highlight">pause</span> で、読み取りはできても書き込みができない状態になる。
  書き込みを再開したい場合は <span class="highlight">promote</span> を指定するか、
  復旧後に <span class="highlight">SELECT pg_wal_replay_resume();</span> を実行して通常稼働へ移行します。
  </p>
</div>
<div class="column">
  <div class="column-title">参考質問例</div>
  <p class="column-note">
  「PostgreSQLのLSNとは何を表す値かを説明し、<code>recovery_target_time</code> と比べたときにLSN指定が有利になる場面を1つ挙げてください。」
  </p>
</div>

<h3>3.5 「ダンプ復元」との違い</h3>
<p>
<code>pg_dump</code> + <code>psql</code> の復元は「ダンプ取得時点へ戻す」方式であり、時点指定には対応できません。
一方、PITRはベースバックアップとWALを組み合わせることで、「誤操作直前」など細かい時点へ戻せます。
</p>
<ul>
  <li><span class="highlight">復旧粒度</span>：<code>pg_dump</code> + <code>psql</code> は取得時点単位、PITRは秒単位の時点指定に対応します。</li>
  <li><span class="highlight">主な用途</span>：論理バックアップは移行・部分復元、PITRは障害直前への巻き戻しに向きます。</li>
  <li><span class="highlight">前提条件</span>：PITRにはベースバックアップ運用とWALアーカイブ運用の両方が必要です。</li>
</ul>

<div class="column">
  <div class="column-title">実務での使い分け</div>
  <p class="column-note">
    「誤操作の数分前に戻したい」ならPITRを選択します。
    「環境移行や一部データの取り出し」が目的なら、<code>pg_dump</code>/<code>pg_restore</code> を優先します。
  </p>
</div>

<h3>3.6 運用での考え方</h3>
<p>
PITRは運用設計とセットで扱う。<span class="highlight-strong">RPO</span>は失ってよい最大時間、<span class="highlight-strong">RTO</span>は復旧に許される時間。これらを意識すると、
どの頻度でバックアップし、どれだけWALを保存すべきか判断できる。
</p>
<ul>
  <li>RPOが短いほどWAL欠落が許されない</li>
  <li>RTOが短いほど復旧手順の自動化が必要</li>
</ul>
<h3>3.7 事例で見るPITR</h3>
<p>
午前中の運用作業で、担当者が間違えて重要テーブルを削除してしまったとします。監視にはエラーが上がり、
ユーザから「データが消えた」と連絡が入った。ここで求められるのは、<span class="highlight">直前の時点に戻す</span>こと。
PITRはこの状況で最短復旧を実現するための選択肢になる。
</p>
<ol>
  <li>「いつ消えたか」を時刻で確定する</li>
  <li>ベースバックアップとWALアーカイブを確認</li>
  <li>復旧ターゲットを設定して再起動</li>
  <li>テーブルの整合性を検証し、業務を再開</li>
</ol>
<div class="column">
  <div class="column-title">現場メモ：時刻の確定が最重要</div>
  <p class="column-note">
  「消えた瞬間の時刻」が曖昧だと、復旧の止めどころが分からない。監査ログやアプリログと照らし合わせ、
  1分単位で時刻を確定します。
  </p>
</div>

<h3>3.8 失敗しやすいパターンと回避策</h3>
<ul>
  <li>WALアーカイブの保存先が満杯 → <span class="highlight">容量監視</span>とローテーションを設計する</li>
  <li>ベースバックアップの世代が古すぎる → <span class="highlight">定期取得</span>を必須化する</li>
  <li>復旧ターゲット時刻が未来 → <span class="highlight">ログ時刻と整合</span>をとる</li>
  <li>復旧後に書き込みできない → <span class="highlight"><code>recovery_target_action</code></span> と <span class="highlight"><code>pg_wal_replay_resume()</code></span> を確認する</li>
</ul>

<h3>3.9 時系列で見るPITR</h3>
<p>
PITRは「まず起点を用意し、次に更新履歴を順に再生し、最後に指定時点で止める」流れです。
</p>

<div class="column">
  <div class="column-title">図解：PITRの時系列フロー</div>
  <pre><code class="language-text">
<span class="time-a">時刻A</span>                    <span class="time-b">時刻B</span>(障害)
 |--------------------------|
 [ベースバックアップ]   [誤操作発生]
         WALアーカイブ（A→B）を順に再生
                          ^
                          |
                復旧ターゲット（B直前）で停止
  </code></pre>
  <p class="column-note">
    ポイントは「ベースバックアップを起点に、WALを前から適用し、目標時点で止める」ことです。
  </p>
</div>

<ol>
  <li><span class="time-a">時刻A</span>でベースバックアップを取得し、復旧の起点を作ります。</li>
  <li><span class="time-a">時刻A</span>から<span class="time-b">時刻B</span>までの更新は、WALアーカイブとして蓄積されます。</li>
  <li><span class="time-b">時刻B</span>で障害または誤操作が発生します。</li>
  <li>復旧時はWALをAから順に適用し、<span class="time-b">時刻B</span>の直前で再生を停止します。</li>
</ol>
<div class="column">
  <div class="column-title">参考質問例</div>
  <p class="column-note">
  「PITRの処理を『ベースバックアップ取得 → WAL蓄積 → 目標時点で停止』の順で説明し、各段階で確認すべきログ/設定を1つずつ挙げてください。」
  </p>
</div>

<h3>定着確認（第3章）</h3>
<ul>
  <li>WALは基本的に<span class="masked">REDOログ</span>として機能する。</li>
  <li>WALだけでは復旧できず、<span class="masked">ベースバックアップ</span>が起点として必要である。</li>
  <li>時点指定復旧で厳密な位置を指定する場合は<span class="masked">LSN</span>が有効である。</li>
</ul>

<h3>3.10 時刻特定の手法・自動ログと手動記録</h3>
<p>
PITRで最も難しいのは「何時何分何秒に戻すべきか」を特定することです。これには主に2つの自動ログが活用されます。
</p>
<div class="column">
  <div class="column-title">1. データベースによる実行ログ（postgresql.log）</div>
  <p class="column-note">
    PostgreSQLの設定で <code>log_statement = 'all'</code> が有効な場合、実行されたすべてのSQLとその時刻がログファイルに自動記録されます。実務ではこのログから「誤操作が行われた正確な時刻」を特定します。
  </p>
</div>
<div class="column">
  <div class="column-title">2. テーブル設計による自動タイムスタンプ</div>
  <p class="column-note">
    今回の演習で使用する <code>x_gold_transfers</code> には、データ挿入時に自動で時刻を記録する <code>transferred_at</code> カラムが定義されています。このように、データそのものに「いつ作られたか」が自動で刻まれる設計にしておくことも、復旧時の重要な手がかりとなります。
  </p>
</div>
<h2>4. ハンズオン学習</h2>
<p>
この章では「誤操作の直前時刻に戻せること」をゴールに、PITRの設定・復旧・確認までを一連で実施します。
ここを先に読んでから手順を進めると、何を触っているかを見失いにくくなります。
</p>

<div class="column">
  <div class="column-title">この章の目的</div>
  <ul class="column-note">
    <li>WALアーカイブ設定を有効化し、復旧可能な状態を作る。</li>
    <li>誤操作（例: <code>DROP TABLE</code>）を再現し、<code>recovery_target_time</code> で巻き戻す。</li>
    <li>復旧後に <code>pg_is_in_recovery()</code> などで状態確認し、通常稼働へ戻す。</li>
  </ul>
</div>

<div class="column">
  <div class="column-title">今から触るファイル</div>
  <ul class="column-note">
    <li><code>/var/lib/postgresql/data/postgresql.auto.conf</code>（復旧パラメータの追記先）</li>
    <li><code>sql/tmp_pitr.sql</code>（手元で実行するSQLの一時ファイル）</li>
    <li><code>from-teacher/10/create-x_db.sql</code>（演習環境を初期化する再構築用SQL）</li>
  </ul>
</div>

<div class="column">
  <div class="column-title">使用するテーブル</div>
  <ul class="column-note">
    <li><code>pitr_demo</code>（4章で作成するPITR確認用テーブル）</li>
    <li><code>x_characters</code> / <code>x_gold_transfers</code> / <code>x_guild_characters</code> / <code>x_guilds</code>（6章のSQLドリルで利用）</li>
    <li>状態が崩れた場合は <code>from-teacher/10/create-x_db.sql</code> で再構築する。</li>
  </ul>
</div>

<div class="column">
  <div class="column-title">実行の流れ（最短）</div>
  <ol class="column-note">
    <li>作業ディレクトリを <code>DB-PostgreSQL</code> に合わせ、<code>npm run db:up</code> で起動確認。</li>
    <li><code>postgresql.auto.conf</code> に <code>restore_command</code> などを設定し再起動。</li>
    <li>SQLは <code>npm run sql sql/tmp_pitr.sql</code> で実行し、時刻を記録して復旧ターゲットに使う。</li>
    <li>復旧後は検証クエリで整合性確認し、必要に応じて通常稼働へ移行する。</li>
  </ol>
</div>

<h3>4.1 作業用ディレクトリの準備</h3>
<p>バックアップ先とアーカイブ先を明示的に作成します。</p>
<p>
このハンズオンは、講義資料どおりに構築済みの <span class="highlight">DB-PostgreSQL</span> フォルダを前提とします。
VSCodeでDB-PostgreSQLを開き、ターミナルはそのフォルダを作業ディレクトリにしてください。
</p>
<p>
まずはターミナルの作業場所とコンテナの起動状況を確認します。ここがズレると以降の作業がすべてズレるため、
最初に丁寧に確認しておきます。
</p>
<pre><code class="language-bash">
# VSCodeでプロジェクトを開いた状態で実行。PowerShell想定
pwd
</code></pre>
<p>出力が <span class="highlight">DB-PostgreSQL</span> 配下であることを確認してください。</p>
<div class="column">
  <div class="column-title">補足：演習環境の起動確認</div>
  <p class="column-note">
  まだコンテナが起動していない場合は、講義資料の手順に従って起動してください。
  </p>
</div>
<pre><code class="language-bash">
# Dockerコンテナ起動。講義資料の手順に従う
npm run db:up
</code></pre>
<pre><code class="language-bash">
# 起動確認
docker ps
</code></pre>
<pre><code class="language-bash">
mkdir -p /backup/base
mkdir -p /backup/wal_archive
</code></pre>

<h3>4.2 WALアーカイブ設定の確認</h3>
<p>
まずは現在の設定を確認します。設定ファイルを直接編集する場合は、操作権限と再起動が必要になるため注意してください。
</p>
<div class="column">
  <div class="column-title">Docker環境の設定ファイル編集 重要</div>
  <p class="column-note">
  Docker環境ではコンテナ内の <span class="highlight">/var/lib/postgresql/data/postgresql.conf</span> が本体設定。
  ただし、PITRの一時的な設定は <span class="highlight">postgresql.auto.conf</span> に追記する方が安全。
  例：設定追記 → 再起動、の順に行う。
  </p>
</div>
<pre><code class="language-bash">
# 例: postgresql.auto.conf へ追記。コンテナ内で実行
docker exec -it db-postgres bash -c "echo \"recovery_target_time = '2026-01-27 10:30:00'\" &gt;&gt; /var/lib/postgresql/data/postgresql.auto.conf"
docker exec -it db-postgres bash -c "echo \"recovery_target_timeline = 'latest'\" &gt;&gt; /var/lib/postgresql/data/postgresql.auto.conf"
docker exec -it db-postgres bash -c "echo \"recovery_target_action = 'promote'\" &gt;&gt; /var/lib/postgresql/data/postgresql.auto.conf"
docker exec -it db-postgres bash -c "echo \"restore_command = 'cp /backup/wal_archive/%f %p'\" &gt;&gt; /var/lib/postgresql/data/postgresql.auto.conf"

# 例: 再起動で反映
docker restart db-postgres
</code></pre>
<p>
設定を変える前に、<span class="highlight">今の値を控える</span>ことは<span class="critical-text">必須</span>です。戻せなくなると原因調査が難しくなります。
</p>
<p>
SQLの実行は、講義資料どおりに <span class="highlight">VSCodeのタスク実行</span> または
<span class="highlight">ターミナルからnpm run sql</span> を使う。以下はターミナル実行の例。
</p>
<pre><code class="language-bash">
# 例: 一時ファイルを作ってSQLを実行
code sql/tmp_pitr.sql
npm run sql sql/tmp_pitr.sql
</code></pre>
<pre><code class="language-sql">
SHOW archive_mode;
SHOW archive_command;
SHOW wal_level;
</code></pre>

<p>postgresql.conf の代表的な設定例です。環境に合わせて調整してください。</p>
<pre><code class="language-ini">
archive_mode = on
archive_command = 'test ! -f /backup/wal_archive/%f &amp;&amp; cp %p /backup/wal_archive/%f'
wal_level = replica
</code></pre>
<div class="column">
  <div class="column-title">補足：archive_command が失敗する代表例</div>
  <p class="column-note">
  パスの存在・権限不足・同名ファイルの衝突が多い。`test ! -f` で上書きを防ぎつつ、
  実際にアーカイブ先にファイルが作成されているか確認すること。
  </p>
</div>

<details>
  <summary>演習：archive_command の失敗をどう切り分けますか？</summary>
  <p>
    パス、権限、既存ファイル衝突、ログ出力の4点を順に確認して、
    どこで失敗しているかを1つずつ切り分けてください。
  </p>
</details>
<div class="column">
  <div class="column-title">参考質問例</div>
  <p class="column-note">
  「`archive_command` が失敗したときの切り分け手順を、①パス ②権限 ③既存ファイル衝突 ④ログ確認 の順で具体的に示してください。」
  </p>
</div>

<h3>4.3 ベースバックアップの取得</h3>
<p>ベースバックアップは復旧の起点です。まず取得してください。</p>
<pre><code class="language-bash">
pg_basebackup -D /backup/base -Fp -Xs -P
</code></pre>
<p>
<strong>-D</strong> は出力先、<strong>-Fp</strong> はプレーン形式、<strong>-Xs</strong> はWALのストリーミング取得、<strong>-P</strong> は進捗表示。
</p>

<h3>4.4 WAL生成とアーカイブ確認</h3>
<h4>4.4.1 テスト用テーブル作成</h4>
<pre><code class="language-sql">
CREATE TABLE pitr_demo (
  id SERIAL PRIMARY KEY,
  message TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
</code></pre>

<h4>4.4.2 変更を発生させる</h4>
<pre><code class="language-sql">
INSERT INTO pitr_demo (message) VALUES
  ('first'),
  ('second'),
  ('third');
</code></pre>

<h4>4.4.3 WALアーカイブの生成を促す</h4>
<pre><code class="language-sql">
SELECT pg_switch_wal();
</code></pre>

<h4>4.4.4 アーカイブ確認</h4>
<pre><code class="language-bash">
ls -la /backup/wal_archive
</code></pre>

<h3>4.5 障害発生の再現</h3>
<p>削除直前の時刻を記録してください。復旧ターゲットとして使用します。</p>
<pre><code class="language-sql">
SELECT now();
SELECT * FROM pitr_demo ORDER BY id;
</code></pre>

<p>誤操作として削除を実行。</p>
<pre><code class="language-sql">
DROP TABLE pitr_demo;
</code></pre>

<h3>4.6 PITRによる復旧</h3>
<h4>4.6.1 目標時刻の設定</h4>
<p>削除直前の時刻をメモして、その時刻へ復旧してください。</p>
<pre><code class="language-ini">
recovery_target_time = '2026-01-27 10:30:00'
recovery_target_timeline = 'latest'
recovery_target_action = 'promote'
</code></pre>
<p>
<span class="highlight"><code>recovery_target_action = 'promote'</code></span> を指定しない場合は <code>pause</code> になるので、
復旧後に書き込みができない状態になる。pauseのままにする場合は、
復旧後に <span class="highlight">SELECT pg_wal_replay_resume();</span> を実行して通常稼働へ移行します。
</p>

<h4>4.6.2 リストア用の基本設定</h4>
<pre><code class="language-ini">
restore_command = 'cp /backup/wal_archive/%f %p'
</code></pre>
<p>
ここでパスを間違えると、<span class="highlight">無言で復旧が進まない</span>ことがあります。ログ確認を必ずセットで実施してください。
</p>

<h4>4.6.3 復旧シグナルの用意</h4>
<pre><code class="language-bash">
touch recovery.signal
</code></pre>
<p>
Docker環境では <span class="highlight">/var/lib/postgresql/data</span> に作成します。例：
<span class="highlight">docker exec -it db-postgres bash -c "touch /var/lib/postgresql/data/recovery.signal"</span>
</p>
<p>
このコマンドは <span class="highlight">コンテナが起動している状態</span>で実行する必要がある。
実行直後に <span class="highlight">docker restart db-postgres</span> を行う流れにすると迷いにくい。
</p>
<div class="column">
  <div class="column-title">順序の確認 重要</div>
  <p class="column-note">
  1) <span class="highlight">設定ファイルを反映</span>。postgresql.auto.conf へ追記 →
  2) <span class="highlight">recovery.signal を作成</span> →
  3) <span class="highlight">サーバー起動</span>。コンテナ start
  この順序が崩れると、<span class="critical-text">設定が反映されないまま起動して復旧が進まない</span>ことがある。
  </p>
</div>

<h4>4.6.4 復旧後の確認</h4>
<pre><code class="language-sql">
SELECT * FROM pitr_demo ORDER BY id;
</code></pre>

<h4>4.6.5 復旧状況の監視コマンド</h4>
<pre><code class="language-sql">
-- 復旧中かどうか
SELECT pg_is_in_recovery();

-- 受信済み/再生済みのWAL位置
SELECT pg_last_wal_receive_lsn();
SELECT pg_last_wal_replay_lsn();

-- 最後に再生したトランザクション時刻
SELECT pg_last_xact_replay_timestamp();
</code></pre>

<h3>定着確認（第4章）</h3>
<ul>
  <li><span class="masked">restore_command</span> の設定ミスは<span class="masked">復旧停止</span>の原因になりやすい。</li>
  <li>復旧手順では <span class="masked">設定反映 → recovery.signal作成 → 起動</span> の順序を守る。</li>
  <li>復旧状態の確認には <span class="masked">pg_is_in_recovery()</span> を使う。</li>
</ul>

<h2>5. 注意点</h2>
<ul>
  <li>アーカイブ先のパスと権限を確認する。</li>
  <li><code>archive_command</code> の成否をログで確認する。</li>
  <li><code>recovery_target_time</code> の形式を確認する。</li>
  <li>ベースバックアップ取得後のWAL欠落有無を確認する。</li>
  <li>復旧後に起動が完了しない場合はターゲット時刻到達を確認する。</li>
  <li>復旧後にアプリが動かない場合は<span class="highlight">接続先が旧DBのまま</span>でないか確認する。</li>
</ul>

<h3>5.1 失敗体験</h3>
<p>
「意図的な失敗」を組み込み、トラブルシューティングの手順を確認します。
</p>
<ol>
  <li><code>restore_command</code> のパスをわざと間違える</li>
  <li>起動後に <span class="highlight">復旧が進まない</span>ことを確認</li>
  <li><span class="highlight">docker logs db-postgres</span> でエラーを確認</li>
  <li>正しいパスに戻して復旧を再実行</li>
</ol>

<h3>5.2 WALの掃除</h3>
<p>
WALアーカイブを溜め続けるとディスクが溢れます。古いWALを削除する場合は
<code>pg_archivecleanup</code> の利用を検討してください。
</p>
<pre><code class="language-bash">
# 例: 古いWALを削除。最新のWALファイルを基準に
pg_archivecleanup /backup/wal_archive 0000000100000000000000A3
</code></pre>

<details>
  <summary>演習：WAL削除の安全条件を説明してください</summary>
  <p>
    「どのベースバックアップに対して、どの時点まで復旧する可能性があるか」を先に決めると、
    消してよいWALの範囲を説明しやすくなります。
  </p>
</details>

<h3>定着確認（第5章）</h3>
<ul>
  <li><span class="masked">archive_command</span> の異常時は <span class="masked">パス・権限・既存ファイル衝突・ログ</span> の順で確認する。</li>
  <li>WAL削除前には <span class="masked">復旧可能範囲</span> を先に定義する。</li>
  <li>復旧後に不整合がある場合は <span class="masked">接続先誤りやWAL欠落</span> を疑う。</li>
</ul>

<h2>6. SQLドリル / 演習</h2>
<p>
本演習では、第10回講義などで構築した <code>x_characters</code> や <code>x_gold_transfers</code> テーブルを使用します。
単にクエリを書くだけでなく、あえて誤ったコードを確定（COMMIT）させ、その後にPITRを用いて正常な状態へ戻すプロセスを体験します。
</p>

<div class="column">
  <div class="column-title">解答例の場所</div>
  <p class="column-note">
    各演習の解答は <a href="#answers">第7章「演習の解答例」</a> にまとめています。演習を実施した後に第7章へ移動して確認してください。
  </p>
</div>

<div class="column">
  <div class="column-title">演習環境の再構築</div>
  <p class="column-note">
    演習の結果、テーブル構造や初期データが不明になった場合は、
    <code>from-teacher/10/create-x_db.sql</code> を実行して環境を初期状態にリセットしてください。
    このスクリプトにより、キャラクター情報やギルド所属情報が正しく再生成されます。
  </p>
</div>

<div class="column">
  <div class="column-title">時刻特定とログの仕組み</div>
  <p class="column-note">
    PITRで最も重要な「復旧時刻」の特定には、主に2つの方法があります。
    一つはデータベースの実行ログ（postgresql.log）を確認する方法で、設定により実行されたSQLと時刻が自動記録されます。
    もう一つは、<code>x_gold_transfers</code> の <code>transferred_at</code> カラムのように、データ自体に自動付与されるタイムスタンプを参照する方法です。
    本演習では <code>SELECT now();</code> を用いて手動で時刻をメモしますが、実務ではこれらの自動ログが頼りになります。
  </p>
</div>

<h3>ex-03_1：条件指定漏れによる全キャラクターの所持金更新</h3>
<p>
特定のキャラクターのゴールドを調整するつもりが、WHERE句を書き忘れたために、全キャラクターのゴールドを0に更新して確定させてしまったケースを再現します。
</p>
<div class="column">
  <div class="column-title">ステップ1：誤操作の実行</div>
  <p class="column-note">まず現在時刻をメモし、以下のコードを実行・確定してください。</p>
<pre><code class="language-sql">
-- 現在時刻をメモ
SELECT now();

BEGIN;
UPDATE x_characters SET gold = 0; 
COMMIT;
</code></pre>
</div>
<div class="column">
  <div class="column-title">ステップ2：リカバリ課題</div>
  <p class="column-note">
    メモした時刻をターゲットにPITRを行い、キャラクターのゴールドが初期値（例：Marvinは50,000G）に戻っているか確認してください。
  </p>
</div>

<hr>

<h3>ex-03_2：報酬配布スクリプトの二重実行</h3>
<p>
配布スクリプトを誤って2回連続で実行したために、送金履歴テーブルに重複したレコードが記録されてしまったケースを再現します。
</p>
<div class="column">
  <div class="column-title">ステップ1：重複データの発生</div>
  <p class="column-note">以下の配布処理を<strong>2回</strong>実行し、COMMITしてください。1回目と2回目の間の時刻を特定する必要があります。</p>
<pre><code class="language-sql">
BEGIN;
INSERT INTO x_gold_transfers (from_character_id, to_character_id, amount, transferred_at)
SELECT '_SYS_', id, 10000, now() FROM x_characters WHERE deleted_at IS NULL;
COMMIT;
</code></pre>
</div>
<div class="column">
  <div class="column-title">ステップ2：リカバリ課題</div>
  <p class="column-note">
    1回目の実行は正当な配布とし、2回目の実行が行われる直前の時刻まで巻き戻して、重複を解消してください。
  </p>
</div>

<hr>

<h3>ex-03_3：物理削除事故</h3>
<p>
本来は論理削除（deleted_atの更新）をすべきところを、誤って物理削除（DELETE）を実行し、ギルド所属情報を消去してしまったケースを再現します。
</p>
<div class="column">
  <div class="column-title">ステップ1：物理削除の実行</div>
<pre><code class="language-sql">
-- 実行前の時刻をメモ
SELECT now();

BEGIN;
DELETE FROM x_guild_characters WHERE character_id = 'C001'; 
COMMIT;
</code></pre>
</div>
<div class="column">
  <div class="column-title">ステップ2：リカバリ課題</div>
  <p class="column-note">
    物理削除されたレコードはROLLBACKでは戻せません。PITRを行い、対象の所属レコードを復活させてください。
  </p>
</div>

<hr>

<h3>ex-03_4：本番テーブルの誤削除</h3>
<p>
作業用テーブルを削除するつもりが、誤って <code>x_guilds</code> テーブルそのものを削除してしまったケースを想定します。
</p>
<div class="column">
  <div class="column-title">リカバリ課題</div>
  <p class="column-note">
    <code>DROP TABLE x_guilds;</code> を実行した後、PITRによってテーブル構造とデータの両方を復旧させてください。
  </p>
</div>

<hr>

<h3>ex-03_5：一斉昇級処理のロジックエラー</h3>
<p>
全キャラクターのゴールドを1.1倍（10%増）にするつもりが、誤って <code>gold * 10</code> （10倍）にして確定してしまったケースを再現します。
</p>
<div class="column">
  <div class="column-title">ステップ1：誤った一斉更新</div>
<pre><code class="language-sql">
BEGIN;
UPDATE x_characters SET gold = gold * 10;
COMMIT;
</code></pre>
</div>
<div class="column">
  <div class="column-title">ステップ2：リカバリ課題</div>
  <p class="column-note">
    経済バランスが壊れた状態から、実行数秒前の時刻を指定して元のゴールド量へ巻き戻してください。
  </p>
</div>

<hr>

<h3>ex-03_6：ギルド解散処理の誤適用</h3>
<p>
特定のギルドのメンバーを脱退させるつもりが、条件指定のミスで全ギルドの所属情報を削除してしまったケースを想定します。
</p>
<div class="column">
  <div class="column-title">リカバリ課題</div>
  <p class="column-note">
    <code>DELETE FROM x_guild_characters;</code> を実行・確定した後、削除直前の時刻を特定し、全メンバーの所属状況を復元してください。
  </p>
</div>

<h2 id="answers">7. 演習の解答例</h2>
<p>各演習に共通する標準的なリカバリ手順の考え方です。時刻やパスは各自の環境に合わせて調整してください。</p>

<details>
<summary>共通リカバリ・テンプレート</summary>
<div class="column">
  <div class="column-title">リカバリ用パラメータ設定</div>
  <p class="column-note">
    postgresql.auto.conf への反映例です。時刻やパスは各自の環境に合わせて書き換えてください。
  </p>
  <pre><code class="language-bash">
# パラメータの記述例
docker exec -it db-postgres bash -c "echo \"restore_command = 'cp /backup/wal_archive/%f %p'\" >> /var/lib/postgresql/data/postgresql.auto.conf"
docker exec -it db-postgres bash -c "echo \"recovery_target_time = '2026-02-16 10:00:00'\" >> /var/lib/postgresql/data/postgresql.auto.conf"
docker exec -it db-postgres bash -c "echo \"recovery_target_timeline = 'latest'\" >> /var/lib/postgresql/data/postgresql.auto.conf"
docker exec -it db-postgres bash -c "echo \"recovery_target_action = 'promote'\" >> /var/lib/postgresql/data/postgresql.auto.conf"
  </code></pre>
</div>

<div class="column">
  <div class="column-title">復旧後の確認と再開用SQL</div>
  <p class="column-note">
    リカバリ完了後、データベースの状態を確認し、必要に応じて通常稼働へ移行させます。
  </p>
  <pre><code class="language-sql">
-- リカバリ状態の確認（'t' であればリカバリモード中）
SELECT pg_is_in_recovery();

-- 最後に再生されたトランザクション時刻の確認
SELECT pg_last_xact_replay_timestamp();

-- 通常稼働へ移行（書き込みを許可する）
SELECT pg_wal_replay_resume();
  </code></pre>
</div>
</details>

<hr>

<h3>まとめと復習</h3>
<p>
本講義の要点を復習する。黄色部分をクリックすると正解が表示される。
</p>
<ul>
  <li>PITRを実現するには、ベースバックアップと <span class="masked">WALアーカイブ</span> の両方が必須です。</li>
  <li>リカバリを開始するには、データディレクトリ内に <span class="masked">recovery.signal</span> という空ファイルを作成します。</li>
  <li>復旧を止めたい特定の時刻は <span class="masked">recovery_target_time</span> パラメータで指定します。</li>
  <li>リカバリ終了直後、DBは「一時停止」状態になるため、<span class="masked">pg_wal_replay_resume()</span> を実行して通常稼働へ移行させる必要があります。</li>
  <li>物理的な破壊（DROP TABLEなど）は、通常の <span class="masked">ROLLBACK</span> では救済できないため、PITRが有効です。</li>
</ul>

<details>
  <summary>最終演習：PITR手順を3分で説明してください</summary>
  <p>
    「起点（ベースバックアップ）」「履歴（WAL）」「停止条件（recovery_target）」の3要素を順番に説明すると、
    実務でも共有しやすい説明になります。
  </p>
</details>


<p class="footer-text"><span class="highlight">制作時間：22時間</span></p>
<footer class="footer">
  <a class="footer-link" href="https://github.com/Tsubasa213" target="_blank" rel="noopener noreferrer">GitHub</a>
  <p class="footer-text">© copyright 2026 Tsubasa213/つばさ all right resolved.</p>
</footer>

</body>
<script src="main.js"></script>
<script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
<iframe
  src="https://docsbot.ai/iframe/4dWqauk5JhWuOOyVaU35/LcmBqB48fmMf6m6LgGL1"
  frameborder="0"
  scrolling="no"
  class="docsbot-frame">
</iframe>
</html>


<!-- https://qiita.com/yaju/items/51e7b1037a99856e547c　めも -->